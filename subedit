#!/usr/bin/bash


#	Copyright 2016-2017 George Savvidis, Odysseas Raftopoulos

#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 2 of the License, or
#	(at your option) any later version.

#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.

#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Define regular expressions
regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"
regexsub="^\{([0-9]+)\}\{([0-9]+)\}(.+)$"
regexsub1="^\{[1]\}\{[1]\}(.+)$"


# Help
get_help ()
{
	echo ""
	echo "$(tput setaf 6)NAME $(tput sgr0)"
	echo "    subedit"
	echo ""
	echo "$(tput setaf 6)DESCRIPTION $(tput sgr0)"
	echo "    Command line subtitle editor."
	echo ""
	echo "$(tput setaf 6)PARAMETERS $(tput sgr0)"
	echo "    -i        Input file. Takes value of a fullpath or a filename in your working directory."
	echo "    -s        Shift time. Takes value of type 'hh:mm:ss:fff'."
	echo "    -p        Switch. Changes the fps from NTSC to PAL."
	echo "    -n        Switch. Changes the fps from PAL to NTSC."
	echo "    -a        Adjust time. Takes value of type '(+/-)hh:mm:ss,fff_(+/-)hh:mm:ss,fff'."
	echo "    -h        Display this info and exit."
	exit
}


# If no parameter is given then exit
if ( ! getopts ":i:s:pna:1:2:y:e:E:t:u:U:h" opt); then
	echo "Try 'subedit -h' for more information."; exit 1;
fi

# Processing parameters
while getopts ":i:s:pna:1:2:y:e:E:t:u:U:h" parameter; do
	case "$parameter" in
		i) inputfilename=$OPTARG ;;
		s) shifttime=$OPTARG ;;
		p) ntsc2pal="True" ;;
		n) pal2ntsc="True" ;;
		a)	eval "adjustfirst=\$$((OPTIND-1))"
			eval "adjustlast=\$$((OPTIND))"
			((OPTIND++)) ;;
		1) adjustonlyfirst=$OPTARG ;;
		2) adjustonlylast=$OPTARG ;;
		y) synchronizefile=$OPTARG ;;
		e)	eval "replace1=\$$((OPTIND-1))"
			eval "replace2=\$$((OPTIND))"
			((OPTIND++)) ;;
		E)	eval "replace3=\$$((OPTIND-1))"
			eval "replace4=\$$((OPTIND))"
			((OPTIND++)) ;;
		t) sub2srt=$OPTARG ;;
		u) srt2sub=$OPTARG ;;
		U) srt2sub=$OPTARG ; srt2sub_delsrttags="True" ;;
		h) get_help ;;
		?) echo -e "Parameter -$OPTARG is unknown or an argument is missing.\nTry 'subedit -h' for more information."; exit 1 ;;
	esac
done


### Helper functions
check_file ()
{
	if ! [[ $(file -b "$1") == *"text"* ]]; then
		echo "Error: \"$1\" is not a text file or it is UTF-16 without BOM"
		exit 1
	fi
}


check_srt ()
{
	srtok=""
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$i]} =~ $regextime ]]; then
			if [[ $2 ]]; then echo $2; fi
			srtok="true"
			break
		fi
	done

	if ! [[ $srtok ]]; then
		echo "Error: \"$1\" is not a valid srt file"; exit 1
	fi
}


check_sub ()
{
	subok=""
	for ((i=0; i<=${#arraysub[@]}; i++)); do
		line=${arraysub[$i]}

		if ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]]; then
			if [[ $2 ]]; then echo $2; fi
			subok="true"
			break
		fi
	done

	if ! [[ $subok ]]; then
		echo "Error: \"$1\" is not a valid sub file"; exit 1
	fi
}


check_srt_and_sub ()
{
	unix2dos -q "$1" 2> /dev/null

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	encoding=$(file -b --mime-encoding "$1")

	array=()
	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		array+=($line)
	done

	IFS=$old_IFS		# restore default field separator

	subtitleis=""
	for ((i=0; i<=${#array[@]}; i++)); do
		if ! [[ ${array[$i]} =~ $regexsub1 ]] && [[ ${array[$i]} =~ $regexsub ]]; then
			if [[ $2 ]]; then echo $2; fi
			subtitleis="sub"
			break
		elif [[ ${array[$i]} =~ $regextime ]]; then
			if [[ $2 ]]; then echo $2; fi
			subtitleis="srt"
			break
		fi
	done

	if ! [[ $subtitleis ]]; then
		echo "Error: \"$1\" is not a valid srt or sub file"; exit 1
	fi
}


### Main functions
shift_time ()
{
	# Calculate the time to move the subs
	regexshift="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $shifttime =~ $regexshift ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi

	p=$sign$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


	# Check if the input file is a text
	check_file "$inputfilename"

	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Check if the srt is OK
	check_srt "$inputfilename" "Shifting time of \"$inputfilename\" by $shifttime..."


	# Process the array
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p1 + $p))
			p2_new=$(($p2 + $p))

			if (( $p1_new < 0 )); then
				echo "Error: Negative time not allowed. Check the shifting value."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


change_fps ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Check if the srt is OK
	if [[ $pal2ntsc ]]; then
		check_srt "$inputfilename" "Changing fps of \"$inputfilename\" from PAL (25) to NTSC (23.976 or 29.970)..."
	elif [[ $ntsc2pal ]]; then
		check_srt "$inputfilename" "Changing fps of \"$inputfilename\" from NTSC (23.976 or 29.970) to PAL (25)..."
	fi


	# Process the array
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			if [[ $pal2ntsc ]]; then
				p1_new=$(($p1 * 1001 / 960))
				p2_new=$(($p2 * 1001 / 960))
			elif [[ $ntsc2pal ]]; then
				p1_new=$(($p1 * 960 / 1001))
				p2_new=$(($p2 * 960 / 1001))
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


adjust_time ()
{
	# Calculate the time to move the subs
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	if [[ $adjustfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'"; exit 1
	fi

	if [[ $adjustlast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Check if the srt is OK
	check_srt "$inputfilename" "Adjusting time of \"$inputfilename\"..."


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Calculate the NEW first and last subtitle
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $p >= $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; exit 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


adjust_time_v2 ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator

	# Check if the srt is OK
	check_srt "$inputfilename" "Adjusting time of \"$inputfilename\"..."


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	if (( 10#$m1a >= 60 )) || (( 10#$s1a >= 60 )) || (( 10#$m1b >= 60 )) || (( 10#$s1b >= 60 )); then
		echo "Error: The first or last subtitle time is invalid."; exit 1
	fi

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Calculate the time to move the subs
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	if ! [[ $adjustonlyfirst ]]; then
		h=$h1a
		m=$m1a
		s=$s1a
		f=$f1a
	elif [[ $adjustonlyfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff'"; exit 1
	fi

	if ! [[ $adjustonlylast ]]; then
		h_=$h1b
		m_=$m1b
		s_=$s1b
		f_=$f1b
	elif [[ $adjustonlylast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi


	# Calculate the NEW first and last subtitle
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $p >= $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; exit 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


synchronize_with_file ()
{
	# Check if the synchronize file is a text
	check_file "$synchronizefile"

	# Read file to synchronize to
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$synchronizefile"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Check if the srt is OK
	check_srt "$synchronizefile"


	# Find the first and last subtitle time of the file to synchronize to
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h="${BASH_REMATCH[1]}"
			m="${BASH_REMATCH[2]}"
			s="${BASH_REMATCH[3]}"
			f="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h_="${BASH_REMATCH[1]}"
			m_="${BASH_REMATCH[2]}"
			s_="${BASH_REMATCH[3]}"
			f_="${BASH_REMATCH[4]}"

			break
		fi
	done

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: The first or last subtitle time of the subtitle you want to synchronize with, is invalid."; exit 1
	fi

	# Calculate the NEW first and last subtitle
	p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))

	if (( $p >= $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	unix2dos -q "$inputfilename"

	# Read text file to array
	arraysrt=()
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Check if the srt is OK
	check_srt "$inputfilename" "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


replace_text ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	if [[ $replace3 ]]; then
		replace1=$replace3
		replace2=$replace4
	fi

	# Define forbitten and allowed regex
	regexforbittensynbols="^[0-9<>\/:{}\$=#-,]+$"
	regexallowedtimes="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframes="^\{[0-9]+\}\{[0-9]+\}$"
	regexallowedtime="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframe="^\{[0-9]+\}$"

	if ! [[  $replace1 =~  $regexallowedtimes ]] && ! [[  $replace1 =~  $regexallowedframes ]] && ! [[  $replace1 =~  $regexallowedtime ]] && ! [[  $replace1 =~  $regexallowedframe ]] && [[ $replace1 =~ $regexforbittensynbols ]]; then
		echo "Error: You cannot replace this"; exit 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Replacing \"$replace1\" with \"$replace2\" in file \"$inputfilename\""

	if [[ $replace3 ]]; then
		sed -i s"/$replace1/$replace2/g" "$inputfilename"
	else
		sed -i s"/$replace1/$replace2/ig" "$inputfilename"
	fi
}


sub2_srt ()
{
	if [[ $sub2srt == "pal" ]]; then ratio=1; fps=25025
	elif [[ $sub2srt == "film" ]]; then ratio=1; fps=24000
	elif [[ $sub2srt == "ntsc" ]]; then ratio=1; fps=30000
	elif [[ $sub2srt =~ ^[0-9]+$ ]]; then ratio=1; fps=$(($sub2srt * 1001))
	elif [[ $sub2srt =~ ^[0-9]+\.[0-9]*$ ]]; then fpsint=${sub2srt%.*}; fpsdecimal=${sub2srt##*.}; decimallength=${#fpsdecimal}; if (( $decimallength == 0 )); then ratio=1; else ratio=1$(eval printf '0%.0s' {1..$decimallength}); fi; fps=$(($(echo $fpsint$fpsdecimal) * 1001))
	else echo -e "Error: The sub2srt parameter only accepts the arguments pal, film, ntsc or a custom framerate.\n       Pal = 25, film = 23.976 and ntsc = 29.970"; exit 1
	fi

	if [[ "${inputfilename##*.}" != "sub" ]]; then
		echo "Warning: \"$inputfilename\" does not have '.sub' extension"
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	encoding=$(file -b --mime-encoding $inputfilename)
	for line in $(iconv -f $encoding -t utf-8 "$inputfilename"); do
		arraysub+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Check if the sub is OK
	newfilename="${inputfilename%.*}.srt"
	check_sub "$inputfilename" "Converting \"$inputfilename\" to \"$newfilename\"..."


	# Process the arraysub and at the same time create the arraysrt
	arraysrt=()
	linecounter=0
	IFS=$'|'			# new field separator, the new line character in sub file

	for ((i=0; i<=${#arraysub[@]}-1; i++)); do
		line=${arraysub[$i]}

		if ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]]; then
			framesstart="${BASH_REMATCH[1]}"
			framesend="${BASH_REMATCH[2]}"
			subs="${BASH_REMATCH[3]}"

			p1=$((1001000 * $ratio * $framesstart / $fps))
			p2=$((1001000 * $ratio * $framesend / $fps))

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1 / 3600000)) $(($(($p1 % 3600000)) / 60000)) $(($(($p1 % 60000)) / 1000)) $(($p1 % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2 / 3600000)) $(($(($p2 % 3600000)) / 60000)) $(($(($p2 % 60000)) / 1000)) $(($p2 % 1000)))

			read -r -a arraysubs <<< "$subs"

			((linecounter++))
			arraysrt+=("$linecounter")
			arraysrt+=("$j1 --> $j2")
			arraysrt+=("${arraysubs[@]}")
			arraysrt+=("")
		elif [[ $line == "" ]] || (( ${#line} == 1 )) || [[ $line =~ $regexsub1 ]]; then
			:
		else
			echo "Warning: There's something wrong with line $(($i+1)) in the sub file"
		fi
	done

	IFS=$old_IFS		# restore default field separator


	# Write to the txt file the contents of array.
	if (( ${#arraysrt[@]} > 2 )); then
		printf "%s\n" "${arraysrt[@]}" | iconv -f utf-8 -t $encoding > "$newfilename"
	else
		echo "Error: Not a valid sub file"; exit 1
	fi
}


srt2_sub ()
{
	if [[ $srt2sub == "pal" ]]; then ratio=1; fps=25025; firstline="{1}{1}25.000"
	elif [[ $srt2sub == "film" ]]; then ratio=1; fps=24000; firstline="{1}{1}23.976"
	elif [[ $srt2sub == "ntsc" ]]; then ratio=1; fps=30000; firstline="{1}{1}29.970"
	elif [[ $srt2sub =~ ^[0-9]+$ ]]; then ratio=1; fps=$(($srt2sub * 1001)); firstline="{1}{1}$srt2sub.000"
	elif [[ $srt2sub =~ ^[0-9]+\.[0-9]*$ ]]; then fpsint=${srt2sub%.*}; fpsdecimal=${srt2sub##*.}; decimallength=${#fpsdecimal}; if (( $decimallength == 0 )); then ratio=1; trizero="000"; firstline="{1}{1}$srt2sub$trizero"; else ratio=1$(eval printf '0%.0s' {1..$decimallength}); firstline="{1}{1}$srt2sub"; fi; fps=$(($(echo $fpsint$fpsdecimal) * 1001))
	else echo -e "Error: The srt2sub parameter only accepts the arguments pal, film, ntsc or a custom framerate.\n       Pal = 25, film = 23.976 and ntsc = 29.970"; exit 1
	fi

	if [[ "${inputfilename##*.}" != "srt" ]]; then
		echo "Warning: \"$inputfilename\" does not have '.srt' extension"
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	unix2dos -q "$inputfilename"

	# Read text file to array
	# The encoding must be UTF-8
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	encoding=$(file -b --mime-encoding $inputfilename)
	for line in $(iconv -f $encoding -t utf-8 "$inputfilename"); do
		arraysrt+=($line)
	done

	# Check if the srt is OK
	newfilename="${inputfilename%.*}.sub"
	check_srt "$inputfilename" "Converting \"$inputfilename\" to \"$newfilename\"..."


	# Remove non necessary lines
	newarraysrt=()
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$(($i + 1))]} =~ $regextime ]] || [[ ${arraysrt[$(($i + 2))]} =~ $regextime ]]; then
			:
		else
			newarraysrt+=(${arraysrt[$i]})
		fi
	done


	# Assosiative array of color names converted to values used by the sub subtitles
	declare -A colornames

	colornames[indianred]="\$5C5CCD"
	colornames[lightcoral]="\$8080F0"
	colornames[salmon]="\$7280FA"
	colornames[darksalmon]="\$7A96E9"
	colornames[lightsalmon]="\$7AA0FF"
	colornames[crimson]="\$3C14DC"
	colornames[red]="\$0000FF"
	colornames[firebrick]="\$2222B2"
	colornames[darkred]="\$00008B"
	colornames[pink]="\$CBC0FF"
	colornames[lightpink]="\$C1B6FF"
	colornames[hotpink]="\$B469FF"
	colornames[deeppink]="\$9314FF"
	colornames[mediumvioletred]="\$8515C7"
	colornames[palevioletred]="\$9370DB"
	colornames[lightsalmon]="\$7AA0FF"
	colornames[coral]="\$507FFF"
	colornames[tomato]="\$4763FF"
	colornames[orangered]="\$0045FF"
	colornames[darkorange]="\$008CFF"
	colornames[orange]="\$00A5FF"
	colornames[gold]="\$00D7FF"
	colornames[yellow]="\$00FFFF"
	colornames[lightyellow]="\$E0FFFF"
	colornames[lemonchiffon]="\$CDFAFF"
	colornames[lightgoldenrodyellow]="\$D2FAFA"
	colornames[papayawhip]="\$D5EFFF"
	colornames[moccasin]="\$B5E4FF"
	colornames[peachpuff]="\$B9DAFF"
	colornames[palegoldenrod]="\$AAE8EE"
	colornames[khaki]="\$8CE6F0"
	colornames[darkkhaki]="\$6BB7BD"
	colornames[lavender]="\$FAE6E6"
	colornames[thistle]="\$D8BFD8"
	colornames[plum]="\$DDA0DD"
	colornames[violet]="\$EE82EE"
	colornames[orchid]="\$D670DA"
	colornames[fuchsia]="\$FF00FF"
	colornames[magenta]="\$FF00FF"
	colornames[mediumorchid]="\$D355BA"
	colornames[mediumpurple]="\$DB7093"
	colornames[rebeccapurple]="\$993366"
	colornames[blueviolet]="\$E22B8A"
	colornames[darkviolet]="\$D30094"
	colornames[darkorchid]="\$CC3299"
	colornames[darkmagenta]="\$8B008B"
	colornames[purple]="\$800080"
	colornames[indigo]="\$82004B"
	colornames[slateblue]="\$CD5A6A"
	colornames[darkslateblue]="\$8B3D48"
	colornames[mediumslateblue]="\$EE687B"
	colornames[greenyellow]="\$2FFFAD"
	colornames[chartreuse]="\$00FF7F"
	colornames[lawngreen]="\$00FC7C"
	colornames[lime]="\$00FF00"
	colornames[limegreen]="\$32CD32"
	colornames[palegreen]="\$98FB98"
	colornames[lightgreen]="\$90EE90"
	colornames[mediumspringgreen]="\$9AFA00"
	colornames[springgreen]="\$7FFF00"
	colornames[mediumseagreen]="\$71B33C"
	colornames[seagreen]="\$578B2E"
	colornames[forestgreen]="\$228B22"
	colornames[green]="\$008000"
	colornames[darkgreen]="\$006400"
	colornames[yellowgreen]="\$32CD9A"
	colornames[olivedrab]="\$238E6B"
	colornames[olive]="\$008080"
	colornames[darkolivegreen]="\$2F6B55"
	colornames[mediumaquamarine]="\$AACD66"
	colornames[darkseagreen]="\$8BBC8F"
	colornames[lightseagreen]="\$AAB220"
	colornames[darkcyan]="\$8B8B00"
	colornames[teal]="\$808000"
	colornames[aqua]="\$FFFF00"
	colornames[cyan]="\$FFFF00"
	colornames[lightcyan]="\$FFFFE0"
	colornames[paleturquoise]="\$EEEEAF"
	colornames[aquamarine]="\$D4FF7F"
	colornames[turquoise]="\$D0E040"
	colornames[mediumturquoise]="\$CCD148"
	colornames[darkturquoise]="\$D1CE00"
	colornames[cadetblue]="\$A09E5F"
	colornames[steelblue]="\$B48246"
	colornames[lightsteelblue]="\$DEC4B0"
	colornames[powderblue]="\$E6E0B0"
	colornames[lightblue]="\$E6D8AD"
	colornames[skyblue]="\$EBCE87"
	colornames[lightskyblue]="\$FACE87"
	colornames[deepskyblue]="\$FFBF00"
	colornames[dodgerblue]="\$FF901E"
	colornames[cornflowerblue]="\$ED9564"
	colornames[mediumslateblue]="\$EE687B"
	colornames[royalblue]="\$E16941"
	colornames[blue]="\$FF0000"
	colornames[mediumblue]="\$CD0000"
	colornames[darkblue]="\$8B0000"
	colornames[navy]="\$800000"
	colornames[midnightblue]="\$701919"
	colornames[cornsilk]="\$DCF8FF"
	colornames[blanchedalmond]="\$CDEBFF"
	colornames[bisque]="\$C4E4FF"
	colornames[navajowhite]="\$ADDEFF"
	colornames[wheat]="\$B3DEF5"
	colornames[burlywood]="\$87B8DE"
	colornames[tan]="\$8CB4D2"
	colornames[rosybrown]="\$8F8FBC"
	colornames[sandybrown]="\$60A4F4"
	colornames[goldenrod]="\$20A5DA"
	colornames[darkgoldenrod]="\$0B86B8"
	colornames[peru]="\$3F85CD"
	colornames[chocolate]="\$1E69D2"
	colornames[saddlebrown]="\$13458B"
	colornames[sienna]="\$2D52A0"
	colornames[brown]="\$2A2AA5"
	colornames[maroon]="\$000080"
	colornames[white]="\$FFFFFF"
	colornames[snow]="\$FAFAFF"
	colornames[honeydew]="\$F0FFF0"
	colornames[mintcream]="\$FAFFF5"
	colornames[azure]="\$FFFFF0"
	colornames[aliceblue]="\$FFF8F0"
	colornames[ghostwhite]="\$FFF8F8"
	colornames[whitesmoke]="\$F5F5F5"
	colornames[seashell]="\$EEF5FF"
	colornames[beige]="\$DCF5F5"
	colornames[oldlace]="\$E6F5FD"
	colornames[floralwhite]="\$F0FAFF"
	colornames[ivory]="\$F0FFFF"
	colornames[antiquewhite]="\$D7EBFA"
	colornames[linen]="\$E6F0FA"
	colornames[lavenderblush]="\$F5F0FF"
	colornames[mistyrose]="\$E1E4FF"
	colornames[gainsboro]="\$DCDCDC"
	colornames[lightgray]="\$D3D3D3"
	colornames[silver]="\$C0C0C0"
	colornames[darkgray]="\$A9A9A9"
	colornames[gray]="\$808080"
	colornames[dimgray]="\$696969"
	colornames[lightslategray]="\$998877"
	colornames[slategray]="\$908070"
	colornames[darkslategray]="\$4F4F2F"
	colornames[black]="\$000000"


	# Process the newarraysrt and at the same time create the arraysub
	IFS=$'\r'
	elementsub=()
	stringsub=()
	framesub=""
	arraysub=()
	arraysub+=($firstline)

	# Regular expression of srt color code
	regexsrtcolor="([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})"

	# Regular expressions for srt tags. They contain possible sub tags because inside the loop they co-exist
	regex_tag_i="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[bus]>)*(<font[^>]*>)*(<[bus]>)*)<i>(.*)</i>((</[bus]>)*(</font>)*(</[bus]>)*)$"
	regex_tag_b="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ius]>)*(<font[^>]*>)*(<[ius]>)*)<b>(.*)</b>((</[ius]>)*(</font>)*(</[ius]>)*)$"
	regex_tag_u="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibs]>)*(<font[^>]*>)*(<[ibs]>)*)<u>(.*)</u>((</[ibs]>)*(</font>)*(</[ibs]>)*)$"
	regex_tag_s="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibu]>)*(<font[^>]*>)*(<[ibu]>)*)<s>(.*)</s>((</[ibu]>)*(</font>)*(</[ibu]>)*)$"
	regex_tag_font_color="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_size="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_color_size="^(\|?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_size_color="^(\|?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"

	# Regular expressions for multiple tags that need to become one
	regex_merge_y_tags="^(\|?(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?)({y:([ibus])})?({y:([ibus])})?({y:([ibus])})?({y:([ibus])})?(.*)$"
	regex_merge_Y_tags="^((\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?)({Y:([ibus])})?({Y:([ibus])})?({Y:([ibus])})?({Y:([ibus])})?(.*)$"

	# Regular expression for removing the remaining srt tags
	regexremove="(.*)<[/]?([ibus]|font[^>]*)>(.*)"

	# This was put inside a function because it needs to run twice
	add_arraysub_element ()
	{
		for j in "${elementsub[@]}"; do
			# Search for "<font color ... size>" and "</font>", remove them from the text and add {C:$xxxxxx}{S:xx} if the subtitle is 1 line or {c:$xxxxxx}{s:xx} if it's more
			if [[ $j =~ $regex_tag_font_color_size ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
				srtcolor=${BASH_REMATCH[5]}
				size=${BASH_REMATCH[6]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]] && [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}{S:$size}$temptext2"
					else
						j="$temptext1{c:$subcolor}{s:$size}$temptext2"
					fi
				elif [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				elif [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size ... color>" and "</font>", remove them from the text and add {C:$xxxxxx}{S:xx} if the subtitle is 1 line or {c:$xxxxxx}{s:xx} if it's more
			if [[ $j =~ $regex_tag_font_size_color ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
				size=${BASH_REMATCH[5]}
				srtcolor=${BASH_REMATCH[6]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]] && [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}{S:$size}$temptext2"
					else
						j="$temptext1{c:$subcolor}{s:$size}$temptext2"
					fi
				elif [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				elif [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size>" and "</font>", remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
			# This runs below a second time - not a mistake
			if [[ $j =~ $regex_tag_font_size ]]; then
				size=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				if [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font color>" and "</font>", remove them from the text and add {C:$xxxxxx} if the subtitle is 1 line or {c:$xxxxxx} if it's more
			if [[ $j =~ $regex_tag_font_color ]]; then
				srtcolor=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size>" and "</font>", remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
			if [[ $j =~ $regex_tag_font_size ]]; then
				size=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				if [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<i>" and "</i>", remove them from the text and add {Y:i} if the subtitle is 1 line or {y:i} if it's more
			if [[ $j =~ $regex_tag_i ]] && ! [[ ${BASH_REMATCH[10]} == *"<i>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</i>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:i}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:i}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<b>" and "</b>", remove them from the text and add {Y:b} if the subtitle is 1 line or {y:b} if it's more
			if [[ $j =~ $regex_tag_b ]] && ! [[ ${BASH_REMATCH[10]} == *"<b>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</b>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:b}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:b}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<u>" and "</u>", remove them from the text and add {Y:u} if the subtitle is 1 line or {y:u} if it's more
			if [[ $j =~ $regex_tag_u ]] && ! [[ ${BASH_REMATCH[10]} == *"<u>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</u>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:u}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:u}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<s>" and "</s>", remove them from the text and add {Y:s} if the subtitle is 1 line or {y:s} if it's more
			if [[ $j =~ $regex_tag_s ]] && ! [[ ${BASH_REMATCH[10]} == *"<s>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</s>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:s}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:s}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Merge multiple y tags
			if [[ $j =~ $regex_merge_y_tags ]] && [[ ${BASH_REMATCH[4]} ]]; then
				j="${BASH_REMATCH[1]}{y:${BASH_REMATCH[5]}${BASH_REMATCH[7]}${BASH_REMATCH[9]}${BASH_REMATCH[11]}}${BASH_REMATCH[12]}"
			fi

			stringsub=${stringsub:+$stringsub}$j
		done

		# Search for "<s>" and "</s>" that enclose all lines, remove them from the text and add {Y:s}
		if [[ $stringsub =~ $regex_tag_s ]] && ! [[ ${BASH_REMATCH[10]} == *"<s>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</s>"* ]]; then
			stringsub="{Y:s}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<u>" and "</u>" that enclose all lines, remove them from the text and add {Y:u}
		if [[ $stringsub =~ $regex_tag_u ]] && ! [[ ${BASH_REMATCH[10]} == *"<u>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</u>"* ]]; then
			stringsub="{Y:u}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<b>" and "</b>" that enclose all lines, remove them from the text and add {Y:b}
		if [[ $stringsub =~ $regex_tag_b ]] && ! [[ ${BASH_REMATCH[10]} == *"<b>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</b>"* ]]; then
			stringsub="{Y:b}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<i>" and "</i>" that enclose all lines, remove them from the text and add {Y:i}
		if [[ $stringsub =~ $regex_tag_i ]] && ! [[ ${BASH_REMATCH[10]} == *"<i>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</i>"* ]]; then
			stringsub="{Y:i}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<font color ... size>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}{S:xx}
		if [[ $stringsub =~ $regex_tag_font_color_size ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
			srtcolor=${BASH_REMATCH[5]}
			size=${BASH_REMATCH[6]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]] && [[ $size ]]; then
				stringsub="{C:$subcolor}{S:$size}$temptext"
			elif [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			elif [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size ... color>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}{S:xx}
		if [[ $stringsub =~ $regex_tag_font_size_color ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
			size=${BASH_REMATCH[5]}
			srtcolor=${BASH_REMATCH[6]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]] && [[ $size ]]; then
				stringsub="{C:$subcolor}{S:$size}$temptext"
			elif [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			elif [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size>" and "</font>" that enclose all lines, remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
		# This runs below a second time - not a mistake
		if [[ $stringsub =~ $regex_tag_font_size ]]; then
			size=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

			if [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font color>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}
		if [[ $stringsub =~ $regex_tag_font_color ]]; then
			srtcolor=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}
			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size>" and "</font>" that enclose all lines, remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
		if [[ $stringsub =~ $regex_tag_font_size ]]; then
			size=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

			if [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Merge multiple Y tags
		if [[ $stringsub =~ $regex_merge_Y_tags ]] && [[ ${BASH_REMATCH[4]} ]]; then
			stringsub="${BASH_REMATCH[1]}{Y:${BASH_REMATCH[5]}${BASH_REMATCH[7]}${BASH_REMATCH[9]}${BASH_REMATCH[11]}}${BASH_REMATCH[12]}"
		fi

		# Remove the remaining srt tags
		if [[ $srt2sub_delsrttags ]]; then
			while [[ $stringsub =~ $regexremove ]]; do
				stringsub=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
			done
		fi

		arraysub+=($framesub$stringsub)
	}

	for ((i=0; i<${#newarraysrt[@]}; i++)); do
		line=${newarraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			# Remove empty lines at the end
			while :; do
				if (( ${#elementsub[@]} > 0 )) && (( ${#elementsub[-1]} == 1 )); then
					unset elementsub[-1]
				else
					break
				fi
			done

			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			framesstart=$(($fps * $p1 / (($ratio * 1001000))))
			framesend=$(($fps * $p2 / (($ratio * 1001000))))

			add_arraysub_element

			unset elementsub
			stringsub=""

			framesub="{$framesstart}{$framesend}"

		elif [[ $elementsub ]]; then
			elementsub+=(\|$line)
		else
			elementsub+=($line)
		fi
	done

	# Remove empty lines at the end
	while :; do
		if (( ${#elementsub[@]} > 0 )) && (( ${#elementsub[-1]} == 1 )); then
			unset elementsub[-1]
		else
			break
		fi
	done

	# Run for the last subtitle
	add_arraysub_element

	# Write to the txt file the contents of array.
	if (( ${#arraysub[@]} >= 1 )); then
		printf "%s\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$newfilename"
	else
		echo "Error: Not a valid srt file"; exit 1
	fi
	IFS=$old_IFS		# restore default field separator
}


if [[ $inputfilename ]]; then
	if [[ $shifttime ]]; then
		shift_time
	elif [[ $pal2ntsc ]]; then
		change_fps
	elif [[ $ntsc2pal ]]; then
		change_fps
	elif [[ $adjustfirst ]]; then
		adjust_time
	elif [[ $adjustonlyfirst ]]; then
		adjust_time_v2
	elif [[ $adjustonlylast ]]; then
		adjust_time_v2
	elif [[ $synchronizefile ]]; then
		synchronize_with_file
	elif [[ $replace1 ]]; then
		replace_text
	elif [[ $replace3 ]]; then
		replace_text
	elif [[ $sub2srt ]]; then
		sub2_srt
	elif [[ $srt2sub ]]; then
		srt2_sub
	fi
	exit 0
fi
