#!/usr/bin/bash


#	Copyright 2016-2017 George Savvidis, Odysseas Raftopoulos

#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 2 of the License, or
#	(at your option) any later version.

#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.

#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Define colors and bold letters
green=$(tput setaf 2)
cyan=$(tput setaf 6)
bold=$(tput bold)
normal=$(tput sgr0)

# Define regular expressions
regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"
regexsub="^\{([0-9]+)\}\{([0-9]+)\}(.+)$"
regexsub1="^\{[1]\}\{[1]\}(.+)$"


# Help
get_help ()
{
case $((10#$(date +%S)%2)) in
	0) authors[0]="George Savvidis (stargr@gmail.com)"; authors[1]="Odysseas Raftopoulos" ;;
	1) authors[0]="Odysseas Raftopoulos"; authors[1]="George Savvidis (stargr@gmail.com)" ;;
esac

text1="
${cyan}NAME${normal}
  subedit


${cyan}DESCRIPTION${normal}
  Command line srt subtitle editor.


${cyan}PARAMETERS${normal}
  ${bold}-i${normal}      Input file. Takes value of a fullpath or a filename in your working
          directory.
  ${bold}-s${normal}      Shift time. Syntax: '(+/-/a/z)hh:mm:ss,fff'.
  ${bold}-p${normal}      Switch. Changes the fps from NTSC (23.976/29.970) to PAL (25).
  ${bold}-n${normal}      Switch. Changes the fps from PAL (25) to NTSC (23.976/29.970).
  ${bold}-a${normal}      Adjust time. Syntax: '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'.
  ${bold}-1${normal}      Adjust beginning time. Syntax: '(+/-)hh:mm:ss,fff'.
  ${bold}-2${normal}      Adjust end time. Syntax: '(+/-)hh:mm:ss,fff'.
  ${bold}-y${normal}      Synchronize with file. Takes value of a fullpath or a filename in your
          working directory.
  ${bold}-Y${normal}      Optional switch, to be used with -y. Replaces times of file to be
          synchronized with the times of the synchronization file.
  ${bold}-e${normal}      Replace, case insensitive. Syntax: '\"Text to be replaced\" \"New text\"'.
          The double quotes are necessary.
  ${bold}-E${normal}      Replace, case sensitive. Syntax: '\"Text to be replaced\" \"New text\"'.
          The double quotes are necessary.
  ${bold}-t${normal}      Convert sub to srt. Syntax: 'film' or 'ntsc' or 'pal' or custom fps
          (Pal = 25, film = 23.976 and ntsc = 29.970).
  ${bold}-u${normal}      Convert srt to sub. Syntax: 'film' or 'ntsc' or 'pal' or custom fps
          (Pal = 25, film = 23.976 and ntsc = 29.970).
  ${bold}-U${normal}      Convert srt to sub. Same as the -u parameter above but also ignores any
          srt tags that were not converted to respective sub tags.
  ${bold}-j${normal}      Join two srt subtitles. Takes value of a fullpath or a filename in your
          working directory.
  ${bold}-J${normal}      Join time. Optional parameter, to be used with -j. Syntax: 'hh:mm:ss,fff'.
  ${bold}-x${normal}      Split srt subtitle. Syntax: '(+/-)hh:mm:ss,fff' or '(+/-)SUB_INTEGER' or
          '(+/-)INTEGER:INTEGERt' or '(+/-)INTEGER:INTEGERn'
  ${bold}-X${normal}      Split time. Optional switch, to be used with -x. Makes second generated
          file begin with time 00:00:00,000.
  ${bold}-h${normal}      Display help.
  ${bold}-H${normal}      Display help with more information and examples.
"

text2="
${cyan}NOTES${normal}
  Filenames must be enclosed in quotes if they contain spaces or other special characters.
  -i (input file) is required in every case.
  -s parameter: plus sign (or no sign at all) adds time, where the minus sign subtracts time.
  -a, -1 and -2 parameters can take absolute time value or shifting time value if you use the +/-.
  -1 and -2 parameters can be combined (equivalent of using just -a).
  -e and -E parameters (replace) work with both srt and sub subtitle files.
  -t parameter (sub to srt) needs a sub subtitle file.
  -J shifts the time after beginning of the second file in the output file.
  -x can take 4 different syntaxes:
    i)   '(+/-)hh:mm:ss,fff':     splitting time.
    ii)  '(+/-)SUB_INTEGER':      splitting subtitle integer.
    iii) '(+/-)INTEGER:INTEGERt': fraction where we split the subtitle file according to total time.
    iv)  '(+/-)INTEGER:INTEGERn': fraction where we split the subtitle file according to number of subtitles.
    The minus sign means that counting begins from the end of the subtitle file.
    The plus sign means that counting begins from the beginning. (Equivalent of using no sign at all).
  Bellow you'll find examples for every parameter.


${cyan}EXAMPLES${normal}

  ${bold}Shift time${normal}

  ${bold}${green}Example 1${normal}
  subedit -i foo.srt -s 00:00:03,100
  Shifts time by 3.1 seconds.

  ${bold}${green}Example 2${normal}
  subedit -i foo.srt -s +00:00:03,100
  The same as above.

  ${bold}${green}Example 3${normal}
  subedit -i foo.srt -s -00:00:02,500
  Shifts time by -2.5 seconds.

  ${bold}${green}Example 4${normal}
  subedit -i foo.srt -s a00:00:11,530
  Calculates and applies the appropriate shift time value so that the first subtitle starts at 00:00:11,530.

  ${bold}${green}Example 5${normal}
  subedit -i foo.srt -s z01:38:32,600
  Calculates and applies the appropriate shift time value so that the last subtitle starts at 01:38:32,600.

  ${bold}Convert NTSC to PAL${normal}

  ${bold}${green}Example 6${normal}
  subedit -i foo.srt -p


  ${bold}Convert PAL to NTSC${normal}

  ${bold}${green}Example 7${normal}
  subedit -i foo.srt -n


  ${bold}Adjust time${normal}

  ${bold}${green}Example 8${normal}
  subedit -i foo.srt -a 00:00:17,360 00:48:02,200
  Sets beginning time to 00:00:17,360 and end time to 00:48:02,200.
  Both times are absolute.

  ${bold}${green}Example 9${normal}
  subedit -i foo.srt -a +00:00:02,600 -00:00:05,920
  Shifts beginning time by +00:00:02,600 and end time by -00:00:05,920.
  Both times are relative.

  ${bold}${green}Example 10${normal}
  subedit -i foo.srt -a 00:00:17,360 -00:00:05,920
  Sets beginning time to 00:00:17,360 and shifts end time by -00:00:05,920.

  ${bold}${green}Example 11${normal}
  subedit -i foo.srt -1 00:00:17,360
  Sets beginning time to 00:00:17,360.

  ${bold}${green}Example 12${normal}
  subedit -i foo.srt -2 +00:00:03,810
  Shifts end time by 00:00:03,810.

  ${bold}${green}Example 13${normal}
  subedit -i foo.srt -1 00:00:17,360 -2 -00:00:05,920
  This has the same result as Example 10.


  ${bold}Synchronize with file${normal}

  ${bold}${green}Example 14${normal}
  subedit -i foo.srt -y boo.srt
  Synchronizes foo.srt with boo.srt. Subtitle times of foo.srt
  will be adjusted with the beginning and end time of boo.srt.

  ${bold}${green}Example 15${normal}
  subedit -i foo.srt -y boo.srt -Y
  Synchronizes foo.srt with boo.srt. Subtitle times of foo.srt
  will be replaced with the times of boo.srt.


  ${bold}Replace text${normal}

  ${bold}${green}Example 16${normal}
  subedit -i foo.srt -e \"George Smlth\" \"George Smith\"
  Replaces text \"george smlth\" (case insensitive) with \"George Smith\".

  ${bold}${green}Example 17${normal}
  subedit -i foo.srt -E \"i'm\" \"I'm\"
  Replaces text \"i'm\" (case sensitive) with \"I'm\".


  ${bold}Convert sub to srt${normal}

  ${bold}${green}Example 18${normal}
  subedit -i foo.sub -t pal
  Assumes that foo.sub is in 25 fps and creates a new file foo.srt.

  ${bold}${green}Example 19${normal}
  subedit -i foo.sub -t film
  Assumes that foo.sub is in 23.976 fps and creates a new file foo.srt.

  ${bold}${green}Example 20${normal}
  subedit -i foo.sub -t ntsc
  Assumes that foo.sub is in 29.970 fps and creates a new file foo.srt.

  ${bold}${green}Example 21${normal}
  subedit -i foo.sub -t 15.338
  Assumes that foo.sub is in 15.338 fps and creates a new file foo.srt.


  ${bold}Convert srt to sub${normal}

  ${bold}${green}Example 22${normal}
  subedit -i foo.srt -u pal
  Creates a new file foo.sub that's in 25 fps.

  ${bold}${green}Example 23${normal}
  subedit -i foo.srt -U pal
  Same as above but any srt tags that were not converted to sub tags will not pass to the .sub file.

  ${bold}${green}Example 24${normal}
  subedit -i foo.srt -u film
  Creates a new file foo.sub that's in 23.976 fps.

  ${bold}${green}Example 25${normal}
  subedit -i foo.srt -u ntsc
  Creates a new file foo.sub that's in 29.970 fps.

  ${bold}${green}Example 26${normal}
  subedit -i foo.srt -u 12
  Creates a new file foo.sub that's in 12 fps.


  ${bold}Join two srt${normal}

  ${bold}${green}Example 27${normal}
  subedit -i foo.srt -j boo.srt
  Joins foo.srt and boo.srt to a new file foo_join.srt.
  The subtitle times in boo.srt are added unmodified.

  ${bold}${green}Example 28${normal}
  subedit -i foo.srt -j boo.srt -J 00:48:05,956
  Joins foo.srt and boo.srt to a new file foo_join.srt.
  The subtitle times in boo.srt are shifted by 00:48:05,956 before added.


  ${bold}Split srt to two files${normal}

  ${bold}${green}Example 29${normal}
  subedit -i foo.srt -x 01:02:39,000
  Splits foo.srt at 01:02:39,000 to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.

  ${bold}${green}Example 30${normal}
  subedit -i foo.srt -x -00:59:14,000
  Splits foo.srt at 00:59:14,000 (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.

  ${bold}${green}Example 31${normal}
  subedit -i foo.srt -x 431
  Splits foo.srt at subtitle number 431 to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.

  ${bold}${green}Example 32${normal}
  subedit -i foo.srt -x -399
  Splits foo.srt at subtitle number 399 (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.

  ${bold}${green}Example 33${normal}
  subedit -i foo.srt -x 1:2t
  Splits foo.srt at 1/2 of total time to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.

  ${bold}${green}Example 34${normal}
  subedit -i foo.srt -x -2:3t
  Splits foo.srt at 2/3 of total time (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.

  ${bold}${green}Example 35${normal}
  subedit -i foo.srt -x 3:4n
  Splits foo.srt at 3/4 of total subtitles to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.

  ${bold}${green}Example 36${normal}
  subedit -i foo.srt -x -1:5n
  Splits foo.srt at 1/5 of total subtitles (counting from the end) to two files foo_1.srt and foo_2.srt.
  The subtitle times in foo_2.srt remain unmodified.

  ${bold}${green}Example 37${normal}
  subedit -i foo.srt -x 01:02:39,000 -X
  Splits foo.srt at 01:02:39,000 to two files foo_1.srt and foo_2.srt.
  foo_2.srt begins with time 00:00:00,000.

  ${bold}${green}Example 38${normal}
  subedit -i foo.srt -x -399 -X
  Splits foo.srt at subtitle number 399 (counting from the end) to two files foo_1.srt and foo_2.srt.
  foo_2.srt begins with time 00:00:00,000.


${cyan}ABOUT${normal}
  Authors:      ${authors[0]}
                ${authors[1]}

  This program is licensed under GPLv2.
"

printf "%s\n" "$text1"
if [[ $longhelp ]]; then
	printf "%s\n" "$text2"
fi
exit 0
}


# If no parameter is given then exit
if ( ! getopts ":i:s:pna:1:2:y:Ye:E:t:u:U:j:J:x:XhH" opt); then
	echo "Try 'subedit -h' for more information."; exit 1;
fi

# Processing parameters
while getopts ":i:s:pna:1:2:y:Ye:E:t:u:U:j:J:x:XhH" parameter; do
	case "$parameter" in
		i) inputfilename=$OPTARG ;;
		s) shifttime=$OPTARG ;;
		p) ntsc2pal="True" ;;
		n) pal2ntsc="True" ;;
		a)	eval "adjustfirst=\$$((OPTIND-1))"
			eval "adjustlast=\$$((OPTIND))"
			((OPTIND++)) ;;
		1) adjustonlyfirst=$OPTARG ;;
		2) adjustonlylast=$OPTARG ;;
		y) synchronizefile=$OPTARG ;;
		Y) synchronizetimebytime="True" ;;
		e)	eval "replace1=\$$((OPTIND-1))"
			eval "replace2=\$$((OPTIND))"
			((OPTIND++)) ;;
		E)	eval "replace3=\$$((OPTIND-1))"
			eval "replace4=\$$((OPTIND))"
			((OPTIND++)) ;;
		t) sub2srt=$OPTARG ;;
		u) srt2sub=$OPTARG ;;
		U) srt2sub=$OPTARG ; srt2sub_delsrttags="True" ;;
		j) joinsrt=$OPTARG ;;
		J) jointime=$OPTARG ;;
		x) splitsrt=$OPTARG ;;
		X) splittime="True" ;;
		h) get_help ;;
		H) longhelp="True"; get_help ;;
		?) echo -e "Parameter -$OPTARG is unknown or an argument is missing.\nTry 'subedit -h' for more information."; exit 1 ;;
	esac
done


### Helper functions
check_file ()
{
	if ! [[ -f "$1" ]]; then
		echo "Error: \"$1\" not found."
		exit 1
	fi

	if ! [[ -r "$1" ]]; then
		echo "Error: \"$1\" is not readable."
		exit 1
	fi

	if ! [[ $(file -b "$1") == *"text"* ]]; then
		echo "Error: \"$1\" is not a text file or it is UTF-16 without BOM"
		exit 1
	fi
}


read_srt ()
{
	unix2dos -q "$1" 2> /dev/null

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	temparraysrt=()
	for line in $(cat "$1"); do
		temparraysrt+=($line)
	done


	# Remove empty subtitles, remove duplicate subtitles and remove extra empty lines before each integer
	buffer=()
	buffer_old=()	# This is used to search for duplicate subtitles
	arraysrt=()
	regexnotonlyspace="^[ ]+[^ ]+.+"
	regexspace="^[ ]+"

	# This was put inside a function because it needs to run twice
	srtcleaning ()
	{
		while :; do
			if [[ $buffer ]] && (( ${#buffer[-1]} == 1 )); then
				unset buffer[-1]
			elif [[ $buffer ]] && [[ ${buffer[-1]} =~ $regexnotonlyspace ]]; then
				break
			elif [[ $buffer ]] && [[ ${buffer[-1]} =~ $regexspace ]]; then
				unset buffer[-1]
			else
				break
			fi
		done

		if [[ $buffer_old ]] && (( ${#buffer_old[@]} == ${#buffer[@]} )); then
			check=1
			for ((j=1; j<=${#buffer_old[@]}-1; j++)); do
				if [[ ${buffer_old[$j],,} == ${buffer[$j],,} ]]; then
					((check++))
				else
					break
				fi
			done
			if (( $check == ${#buffer_old[@]} )); then
				duplicatefound="True"
			fi
		fi

		if ! [[ $duplicatefound ]] && [[ $buffer ]] && ! [[ ${buffer[-1]} =~ $regextime ]]; then
			arraysrt+=("${buffer[@]}")
			arraysrt+=("")
		fi
	}

	for ((i=0; i<=${#temparraysrt[@]}; i++)); do
		if [[ ${temparraysrt[$i]} =~ ^([0-9]+) ]] && [[ ${temparraysrt[((i+1))]} =~ $regextime ]]; then
			srtcleaning

			unset duplicatefound
			buffer_old=()
			buffer_old+=("${buffer[@]}")
			buffer=()
		fi
		buffer+=(${temparraysrt[$i]})
	done

	# Everything inside the previous for-loop must run one last time for the last subtitle
	srtcleaning

	IFS=$old_IFS		# restore default field separator

	# Re-create the subtitle array with new counter
	subcounter=0
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$i]} =~ ^([0-9]+) ]] && [[ ${arraysrt[((i+1))]} =~ $regextime ]]; then
			((subcounter++))
			arraysrt[$i]="$subcounter"
		fi
	done

	# Remove an empty line at the end
	if [[ $arraysrt ]] && (( ${#arraysrt[-1]} == 0 )); then
		unset arraysrt[-1]
	fi
}


read_sub ()
{
	unix2dos -q "$1" 2> /dev/null

	# Remove any empty subtitle lines before the first non-empty dialog line
	# The -b parameter open files in binary mode (CR+LFs are not processed specially) and makes sed behave in Cygwin like in Linux. In Linux it is ignored
	sed -b s'/^\({[0-9]\+}{[0-9]\+}\)\(\({[CSFPY]:[^}]*}\)*\)\([|[:blank:]]*[|]*\({[csfy]:[^}]*}\)*[|[:blank:]]*[|]\)*\(.*\)/\1\2\6/'g -i "$1"

	# Regular expressions for multiple tags that need to become one
	color_size_TAGS="((\{[S]:[0-9]+\})?(\{[C]:[$][A-F0-9]{6}\})?(\{[S]:[0-9]+\})?)"
	color_size_tags="((\{[s]:[0-9]+\})?(\{[c]:[$][A-F0-9]{6}\})?(\{[s]:[0-9]+\})?)"
	regex_merge_Y_tags="^(\{[0-9]+\}\{[0-9]+\}$color_size_TAGS)$color_size_tags({Y:([ibus]+)})?$color_size_TAGS$color_size_tags({Y:([ibus]+)})?$color_size_TAGS$color_size_tags({Y:([ibus]+)})?$color_size_TAGS$color_size_tags({Y:([ibus]+)})?(.*)$"
	regex_merge_y_tags1="^(\{[0-9]+\}\{[0-9]+\}$color_size_TAGS({Y:[ibus]+})?$color_size_tags)({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?(.*)$"
	regex_merge_y_tags2="^($color_size_tags)({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?$color_size_tags({y:([ibus]+)})?(.*)$"

	# Read text file to array and delete empty and duplicate subs
	arraysub=()
	regexemptysub="^\{([0-9]+)\}\{([0-9]+)\}(\{[cCsSfFPyY]:[^}]*\})*([|[:blank:]]*)$cr$"
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	encoding=$(file -b --mime-encoding "$1")

	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		if [[ $line =~ $regexsub1 ]]; then
			arraysub+=($line)
		fi
		break
	done

	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		if ! [[ $line =~ $regexemptysub ]] && ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]] && [[ ${line,,} != ${arraysub[-1],,} ]]; then
			# Merge multiple Y tags
			if [[ $line =~ $regex_merge_Y_tags ]] && [[ ${BASH_REMATCH[10]} ]]; then
				ibus_matches=${BASH_REMATCH[11]}${BASH_REMATCH[21]}${BASH_REMATCH[31]}${BASH_REMATCH[41]}
				tag_values=""
				if [[ $ibus_matches == *"i"* ]]; then tag_values+="i"; fi
				if [[ $ibus_matches == *"b"* ]]; then tag_values+="b"; fi
				if [[ $ibus_matches == *"u"* ]]; then tag_values+="u"; fi
				if [[ $ibus_matches == *"s"* ]]; then tag_values+="s"; fi
				line="${BASH_REMATCH[1]}${BASH_REMATCH[12]}${BASH_REMATCH[22]}${BASH_REMATCH[32]}{Y:$tag_values}${BASH_REMATCH[6]}${BASH_REMATCH[16]}${BASH_REMATCH[26]}${BASH_REMATCH[36]}${BASH_REMATCH[42]}"
			fi

			IFS=$'|'
			read -r -a split_line <<< "$line"
			# Merge multiple y tags in the first line
			if [[ ${split_line[0]} =~ $regex_merge_y_tags1 ]] && [[ ${BASH_REMATCH[11]} ]]; then
				ibus_matches=${BASH_REMATCH[12]}${BASH_REMATCH[18]}${BASH_REMATCH[24]}${BASH_REMATCH[30]}
				tag_values=""
				if [[ $ibus_matches == *"i"* ]]; then tag_values+="i"; fi
				if [[ $ibus_matches == *"b"* ]]; then tag_values+="b"; fi
				if [[ $ibus_matches == *"u"* ]]; then tag_values+="u"; fi
				if [[ $ibus_matches == *"s"* ]]; then tag_values+="s"; fi
				split_line[0]="${BASH_REMATCH[1]}${BASH_REMATCH[13]}${BASH_REMATCH[19]}${BASH_REMATCH[25]}{y:$tag_values}${BASH_REMATCH[31]}"
			fi
			line_new=${split_line[0]}

			# Merge multiple y tags in the rest of the lines
			for ((i=1; i<=${#split_line[@]}-1; i++)); do
				if [[ ${split_line[$i]} =~ $regex_merge_y_tags2 ]] && [[ ${BASH_REMATCH[6]} ]]; then
					ibus_matches=${BASH_REMATCH[7]}${BASH_REMATCH[13]}${BASH_REMATCH[19]}${BASH_REMATCH[25]}
					tag_values=""
					if [[ $ibus_matches == *"i"* ]]; then tag_values+="i"; fi
					if [[ $ibus_matches == *"b"* ]]; then tag_values+="b"; fi
					if [[ $ibus_matches == *"u"* ]]; then tag_values+="u"; fi
					if [[ $ibus_matches == *"s"* ]]; then tag_values+="s"; fi
					split_line[$i]="${BASH_REMATCH[1]}${BASH_REMATCH[8]}${BASH_REMATCH[14]}${BASH_REMATCH[20]}{y:$tag_values}${BASH_REMATCH[26]}"
				fi
				line_new+="|${split_line[$i]}"
			done
			IFS=$'\n'

			arraysub+=($line_new)
		fi 2> /dev/null
	done

	IFS=$old_IFS		# restore default field separator
}


check_srt ()
{
	srtok=""
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$i]} =~ $regextime ]]; then
			if [[ $2 ]]; then echo $2; fi
			srtok="true"
			break
		fi
	done

	if ! [[ $srtok ]]; then
		echo "Error: \"$1\" is not a valid srt file"; exit 1
	fi
}


check_sub ()
{
	subok=""
	for ((i=0; i<=${#arraysub[@]}; i++)); do
		line=${arraysub[$i]}

		if ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]]; then
			if [[ $2 ]]; then echo $2; fi
			subok="true"
			break
		fi
	done

	if ! [[ $subok ]]; then
		echo "Error: \"$1\" is not a valid sub file"; exit 1
	fi
}


check_srt_and_sub ()
{
	unix2dos -q "$1" 2> /dev/null

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	encoding=$(file -b --mime-encoding "$1")

	array=()
	for line in $(iconv -f $encoding -t utf-8 "$1" 2> /dev/null); do
		array+=($line)
	done

	IFS=$old_IFS		# restore default field separator

	subtitleis=""
	for ((i=0; i<=${#array[@]}; i++)); do
		if ! [[ ${array[$i]} =~ $regexsub1 ]] && [[ ${array[$i]} =~ $regexsub ]]; then
			if [[ $2 ]]; then echo $2; fi
			subtitleis="sub"
			break
		elif [[ ${array[$i]} =~ $regextime ]]; then
			if [[ $2 ]]; then echo $2; fi
			subtitleis="srt"
			break
		fi
	done

	if ! [[ $subtitleis ]]; then
		echo "Error: \"$1\" is not a valid srt or sub file"; exit 1
	fi
}


### Main functions
shift_time ()
{
	# Calculate the time to move the subs
	regexshift="^([az+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $shifttime =~ $regexshift ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-/a/z)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi

	givenms=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


	# Check if the input file is a text
	check_file "$inputfilename"

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Shifting time of \"$inputfilename\" by $shifttime..."


	# Find shift milliseconds
	if [[ $sign == "a" ]]; then
		# Find the first subtitle time
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1a="${BASH_REMATCH[1]}"
				m1a="${BASH_REMATCH[2]}"
				s1a="${BASH_REMATCH[3]}"
				f1a="${BASH_REMATCH[4]}"

				break
			fi
		done

		# Time in milliseconds of the start time of the first subtitle
		pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

		# Shift milliseconds
		((p=givenms-pa))
	elif [[ $sign == "z" ]]; then
		# Find the last subtitle time
		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1b="${BASH_REMATCH[1]}"
				m1b="${BASH_REMATCH[2]}"
				s1b="${BASH_REMATCH[3]}"
				f1b="${BASH_REMATCH[4]}"

				break
			fi
		done

		# Time in milliseconds of the start time of the last subtitle
		pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))

		# Shift milliseconds
		((p=givenms-pb))
	else
		# Shift milliseconds
		p=$sign$givenms
	fi


	# Process the array
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p1 + $p))
			p2_new=$(($p2 + $p))

			if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
				echo "Error: Negative time not allowed. Check the shifting value."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


change_fps ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	if [[ $pal2ntsc ]]; then
		check_srt "$inputfilename" "Changing fps of \"$inputfilename\" from PAL (25) to NTSC (23.976 or 29.970)..."
	elif [[ $ntsc2pal ]]; then
		check_srt "$inputfilename" "Changing fps of \"$inputfilename\" from NTSC (23.976 or 29.970) to PAL (25)..."
	fi


	# Process the array
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			if [[ $pal2ntsc ]]; then
				p1_new=$(($p1 * 1001 / 960))
				p2_new=$(($p2 * 1001 / 960))
			elif [[ $ntsc2pal ]]; then
				p1_new=$(($p1 * 960 / 1001))
				p2_new=$(($p2 * 960 / 1001))
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


adjust_time ()
{
	# Calculate the time to move the subs
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $adjustfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'"; exit 1
	fi

	if [[ $adjustlast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Adjusting time of \"$inputfilename\"..."

	# Check if the file has only 1 subtitle
	if ((subcounter == 1)); then
		echo "Error: File has only 1 subtitle. Use Shift time (-s parameter) instead."; exit 1
	fi


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Calculate the NEW first and last subtitle
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $pa == $pb )); then
		echo "Error: Cannot process the file. The first subtitle starts at the same time as the last subtitle"; exit 1
	elif (( $pa > $pb )); then
		echo "Error: Cannot process the file. The first subtitle starts after the last subtitle"; exit 1
	fi

	if (( $p == $p_ )); then
		echo "Error: The first subtitle cannot start at the same time as the last subtitle"; exit 1
	elif (( $p > $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; exit 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


adjust_time_v2 ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Adjusting time of \"$inputfilename\"..."

	# Check if the file has only 1 subtitle
	if ((subcounter == 1)); then
		echo "Error: File has only 1 subtitle. Use Shift time (-s parameter) instead."; exit 1
	fi


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	if (( 10#$m1a >= 60 )) || (( 10#$s1a >= 60 )) || (( 10#$m1b >= 60 )) || (( 10#$s1b >= 60 )); then
		echo "Error: The first or last subtitle time is invalid."; exit 1
	fi

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Calculate the time to move the subs
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if ! [[ $adjustonlyfirst ]]; then
		h=$h1a
		m=$m1a
		s=$s1a
		f=$f1a
	elif [[ $adjustonlyfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff'"; exit 1
	fi

	if ! [[ $adjustonlylast ]]; then
		h_=$h1b
		m_=$m1b
		s_=$s1b
		f_=$f1b
	elif [[ $adjustonlylast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi


	# Calculate the NEW first and last subtitle
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $pa == $pb )); then
		echo "Error: Cannot process the file. The first subtitle starts at the same time as the last subtitle"; exit 1
	elif (( $pa > $pb )); then
		echo "Error: Cannot process the file. The first subtitle starts after the last subtitle"; exit 1
	fi

	if (( $p == $p_ )); then
		echo "Error: The first subtitle cannot start at the same time as the last subtitle"; exit 1
	elif (( $p > $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; exit 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


synchronize_with_file ()
{
	# Check if the synchronize file is a text
	check_file "$synchronizefile"

	# Read file to synchronize to
	read_srt "$synchronizefile"

	# Check if the srt is OK
	check_srt "$synchronizefile"


	if ! [[ $synchronizetimebytime ]]; then
		# Find the first and last subtitle time of the file to synchronize to
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h="${BASH_REMATCH[1]}"
				m="${BASH_REMATCH[2]}"
				s="${BASH_REMATCH[3]}"
				f="${BASH_REMATCH[4]}"

				break
			fi
		done

		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h_="${BASH_REMATCH[1]}"
				m_="${BASH_REMATCH[2]}"
				s_="${BASH_REMATCH[3]}"
				f_="${BASH_REMATCH[4]}"

				break
			fi
		done

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
			echo "Error: The first or last subtitle time of the subtitle you want to synchronize with, is invalid."; exit 1
		fi

		# Calculate the NEW first and last subtitle
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))

		if (( $p == $p_ )); then
			echo "Error: The first subtitle cannot start at the same time as the last subtitle"; exit 1
		elif (( $p > $p_ )); then
			echo "Error: The first subtitle cannot start after the last subtitle"; exit 1
		fi


		# Check if the input file is a text
		check_file "$inputfilename"

		# Read text file to arraysrt
		read_srt "$inputfilename"

		# Check if the srt is OK
		check_srt "$inputfilename" "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."

		# Check if the file has only 1 subtitle
		if ((subcounter == 1)); then
			echo "Error: File has only 1 subtitle. Use Shift time (-s parameter) instead."; exit 1
		fi


		# Find the first and last subtitle time
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1a="${BASH_REMATCH[1]}"
				m1a="${BASH_REMATCH[2]}"
				s1a="${BASH_REMATCH[3]}"
				f1a="${BASH_REMATCH[4]}"

				break
			fi
		done

		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1b="${BASH_REMATCH[1]}"
				m1b="${BASH_REMATCH[2]}"
				s1b="${BASH_REMATCH[3]}"
				f1b="${BASH_REMATCH[4]}"

				break
			fi
		done

		# Time in milliseconds of the start time of the first subtitle
		pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

		# Time in milliseconds of the start time of the last subtitle
		pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))

		if (( $pa == $pb )); then
			echo "Error: Cannot process the file. The first subtitle starts at the same time as the last subtitle"; exit 1
		elif (( $pa > $pb )); then
			echo "Error: Cannot process the file. The first subtitle starts after the last subtitle"; exit 1
		fi


		# Process the array
		diff1=$(($p_ - $p))
		diff2=$(($pb - $pa))

		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
				p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

				p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
				p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

				if (( $p1_new < 0 )) || (( $p2_new < 0 )); then
					echo "Error: Negative time not allowed. Check the adjusting values."; exit 1
				fi

				j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
				j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

				line_new="$j1 --> $j2"

				arraysrt[$i]=$line_new
			fi
		done
	else
		# Copy the times of arraysrt to arraysynchronize
		arraysynchronize=()

		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			if [[ ${arraysrt[$i]} =~ $regextime ]]; then
				arraysynchronize+=("${arraysrt[$i]}")
			fi
		done

		# Check if the input file is a text
		check_file "$inputfilename"

		# Read text file to arraysrt
		read_srt "$inputfilename"

		# Check if the srt is OK
		check_srt "$inputfilename" "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."

		counter=0
		for ((i=0; i<=${#arraysrt[@]}; i++)); do
			if [[ ${arraysrt[$i]} =~ $regextime ]]; then
				if [[ ${arraysynchronize[$counter]} ]]; then
					arraysrt[$i]="${arraysynchronize[$counter]}"
					((counter++))
				else
					break
				fi
			fi
		done
	fi

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


replace_text ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	if [[ $replace3 ]]; then
		replace1=$replace3
		replace2=$replace4
	fi

	# Define forbitten and allowed regex
	regexforbittensynbols="^[0-9<>\/:{}\$=#-,]+$"
	regexallowedtimes="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframes="^\{[0-9]+\}\{[0-9]+\}$"
	regexallowedtime="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframe="^\{[0-9]+\}$"

	if ! [[  $replace1 =~  $regexallowedtimes ]] && ! [[  $replace1 =~  $regexallowedframes ]] && ! [[  $replace1 =~  $regexallowedtime ]] && ! [[  $replace1 =~  $regexallowedframe ]] && [[ $replace1 =~ $regexforbittensynbols ]]; then
		echo "Error: You cannot replace this"; exit 1
	fi

	# Check if the srt or sub is OK
	check_srt_and_sub "$inputfilename" "Replacing \"$replace1\" with \"$replace2\" in file \"$inputfilename\""

	case "$subtitleis" in
		"srt") read_srt "$inputfilename"; printf "%s\n" "${arraysrt[@]}" > "$inputfilename" ;;
		"sub") read_sub "$inputfilename"; printf "%s\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$inputfilename" ;;
	esac

	if [[ $replace3 ]]; then
		sed -b -i s"/$replace1/$replace2/g" "$inputfilename"
	else
		sed -b -i s"/$replace1/$replace2/ig" "$inputfilename"
	fi
}


sub2_srt ()
{
	if [[ $sub2srt == "pal" ]]; then ratio=1; fps=25025
	elif [[ $sub2srt == "film" ]]; then ratio=1; fps=24000
	elif [[ $sub2srt == "ntsc" ]]; then ratio=1; fps=30000
	elif [[ $sub2srt =~ ^[0-9]+$ ]]; then ratio=1; fps=$(($sub2srt * 1001))
	elif [[ $sub2srt =~ ^[0-9]+\.[0-9]*$ ]]; then fpsint=${sub2srt%.*}; fpsdecimal=${sub2srt##*.}; decimallength=${#fpsdecimal}; if (( $decimallength == 0 )); then ratio=1; else ratio=1$(eval printf '0%.0s' {1..$decimallength}); fi; fps=$(($(echo $fpsint$fpsdecimal) * 1001))
	else echo -e "Error: The sub2srt parameter only accepts the arguments pal, film, ntsc or a custom framerate.\n       Pal = 25, film = 23.976 and ntsc = 29.970"; exit 1
	fi

	if [[ "${inputfilename##*.}" != "sub" ]]; then
		echo "Warning: \"$inputfilename\" does not have '.sub' extension"
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Read text file to arraysub
	read_sub "$inputfilename"

	# Check if the sub is OK
	newfilename="${inputfilename%.*}.srt"
	check_sub "$inputfilename" "Converting \"$inputfilename\" to \"$newfilename\"..."


	# Process the arraysub and at the same time create the arraysrt
	arraysrt=()
	linecounter=0
	IFS=$'|'			# new field separator, the new line character in sub file
	tag="\{(c|C|s|S|f|F|P|y|Y):[0-9a-zA-Z$,]+\}"
	regextags="^($tag){1}($tag)?($tag)?($tag)?($tag)?($tag)?($tag)?($tag)?(.+)$"

	for ((i=0; i<=${#arraysub[@]}-1; i++)); do
		line=${arraysub[$i]}

		if ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]]; then
			framesstart="${BASH_REMATCH[1]}"
			framesend="${BASH_REMATCH[2]}"
			subs="${BASH_REMATCH[3]}"

			p1=$((1001000 * $ratio * $framesstart / $fps))
			p2=$((1001000 * $ratio * $framesend / $fps))

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1 / 3600000)) $(($(($p1 % 3600000)) / 60000)) $(($(($p1 % 60000)) / 1000)) $(($p1 % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2 / 3600000)) $(($(($p2 % 3600000)) / 60000)) $(($(($p2 % 60000)) / 1000)) $(($p2 % 1000)))

			read -r -a arraysubs <<< "$subs"

			for ((j=0; j<=${#arraysubs[@]}-1; j++)); do
				text=${arraysubs[$j]}

				if [[ $text =~ $regextags ]]; then
					tagvalue1="${BASH_REMATCH[1]}"
					tag1="${BASH_REMATCH[2]}"
					tagvalue2="${BASH_REMATCH[3]}"
					tag2="${BASH_REMATCH[4]}"
					tagvalue3="${BASH_REMATCH[5]}"
					tag3="${BASH_REMATCH[6]}"
					tagvalue4="${BASH_REMATCH[7]}"
					tag4="${BASH_REMATCH[8]}"
					tagvalue5="${BASH_REMATCH[9]}"
					tag5="${BASH_REMATCH[10]}"
					tagvalue6="${BASH_REMATCH[11]}"
					tag6="${BASH_REMATCH[12]}"
					tagvalue7="${BASH_REMATCH[13]}"
					tag7="${BASH_REMATCH[14]}"
					tagvalue8="${BASH_REMATCH[15]}"
					tag8="${BASH_REMATCH[16]}"
					justtext="${BASH_REMATCH[17]}"

					# Remove tags that are in-between the text.
					unnecessarytags="(.*)\{(c|C|s|S|f|F|P|y|Y):[0-9a-zA-Z$,]+\}(.*)"
					while [[ $justtext =~ $unnecessarytags ]]; do
						justtext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
					done

					# Remove tags that are ignored (position, font).
					arraysubs[$j]=$justtext

					# In YYY we gather the tags that affect all lines and in yyy the tags that affect only one line.
					YYY=""
					yyy=""

					if [[ $tag1 == "Y" ]]; then YYY+=$tagvalue1; fi
					if [[ $tag2 == "Y" ]]; then YYY+=$tagvalue2; fi
					if [[ $tag3 == "Y" ]]; then YYY+=$tagvalue3; fi
					if [[ $tag4 == "Y" ]]; then YYY+=$tagvalue4; fi
					if [[ $tag5 == "Y" ]]; then YYY+=$tagvalue5; fi
					if [[ $tag6 == "Y" ]]; then YYY+=$tagvalue6; fi
					if [[ $tag7 == "Y" ]]; then YYY+=$tagvalue7; fi
					if [[ $tag8 == "Y" ]]; then YYY+=$tagvalue8; fi

					if [[ $tag1 == "y" ]]; then yyy+=$tagvalue1; fi
					if [[ $tag2 == "y" ]]; then yyy+=$tagvalue2; fi
					if [[ $tag3 == "y" ]]; then yyy+=$tagvalue3; fi
					if [[ $tag4 == "y" ]]; then yyy+=$tagvalue4; fi
					if [[ $tag5 == "y" ]]; then yyy+=$tagvalue5; fi
					if [[ $tag6 == "y" ]]; then yyy+=$tagvalue6; fi
					if [[ $tag7 == "y" ]]; then yyy+=$tagvalue7; fi
					if [[ $tag8 == "y" ]]; then yyy+=$tagvalue8; fi

					suffix=""
					case ${YYY,,} in
						*"s"*) justtext="<s>"$justtext; arraysubs[$j]=$justtext; suffix+="</s>" ;;&
						*"u"*) justtext="<u>"$justtext; arraysubs[$j]=$justtext; suffix+="</u>" ;;&
						*"b"*) justtext="<b>"$justtext; arraysubs[$j]=$justtext; suffix+="</b>" ;;&
						*"i"*) justtext="<i>"$justtext; arraysubs[$j]=$justtext; suffix+="</i>" ;;
					esac
					arraysubs[-1]+=$suffix
					if ((${#arraysubs[@]} == 1)); then
						justtext+=$suffix
					fi
					suffix=""

					case ${yyy,,} in
						*"s"*) justtext="<s>"$justtext"</s>"; arraysubs[$j]=$justtext ;;&
						*"u"*) justtext="<u>"$justtext"</u>"; arraysubs[$j]=$justtext ;;&
						*"b"*) justtext="<b>"$justtext"</b>"; arraysubs[$j]=$justtext ;;&
						*"i"*) justtext="<i>"$justtext"</i>"; arraysubs[$j]=$justtext ;;
					esac

					# COLOR is the tag that affect all lines and color the tag that affect only one line.
					COLOR=""
					color=""

					if [[ $tag1 == "C" ]]; then COLOR=$tagvalue1; fi
					if [[ $tag2 == "C" ]]; then COLOR=$tagvalue2; fi
					if [[ $tag3 == "C" ]]; then COLOR=$tagvalue3; fi
					if [[ $tag4 == "C" ]]; then COLOR=$tagvalue4; fi
					if [[ $tag5 == "C" ]]; then COLOR=$tagvalue5; fi
					if [[ $tag6 == "C" ]]; then COLOR=$tagvalue6; fi
					if [[ $tag7 == "C" ]]; then COLOR=$tagvalue7; fi
					if [[ $tag8 == "C" ]]; then COLOR=$tagvalue8; fi

					if [[ $tag1 == "c" ]]; then color=$tagvalue1; fi
					if [[ $tag2 == "c" ]]; then color=$tagvalue2; fi
					if [[ $tag3 == "c" ]]; then color=$tagvalue3; fi
					if [[ $tag4 == "c" ]]; then color=$tagvalue4; fi
					if [[ $tag5 == "c" ]]; then color=$tagvalue5; fi
					if [[ $tag6 == "c" ]]; then color=$tagvalue6; fi
					if [[ $tag7 == "c" ]]; then color=$tagvalue7; fi
					if [[ $tag8 == "c" ]]; then color=$tagvalue8; fi


					regexsubcolor="[$]([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})"
					if [[ $COLOR =~ $regexsubcolor ]]; then
						COLOR="\"#${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}\""
						COLOR=${COLOR,,}
					else
						COLOR=""
					fi

					if [[ $color =~ $regexsubcolor ]]; then
						color="\"#${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}\""
						color=${color,,}
					else
						color=""
					fi

					# SIZE is the tag that affect all lines and size the tag that affect only one line.
					SIZE=""
					size=""

					if [[ $tag1 == "S" ]]; then SIZE=$tagvalue1; fi
					if [[ $tag2 == "S" ]]; then SIZE=$tagvalue2; fi
					if [[ $tag3 == "S" ]]; then SIZE=$tagvalue3; fi
					if [[ $tag4 == "S" ]]; then SIZE=$tagvalue4; fi
					if [[ $tag5 == "S" ]]; then SIZE=$tagvalue5; fi
					if [[ $tag6 == "S" ]]; then SIZE=$tagvalue6; fi
					if [[ $tag7 == "S" ]]; then SIZE=$tagvalue7; fi
					if [[ $tag8 == "S" ]]; then SIZE=$tagvalue8; fi

					if [[ $tag1 == "s" ]]; then size=$tagvalue1; fi
					if [[ $tag2 == "s" ]]; then size=$tagvalue2; fi
					if [[ $tag3 == "s" ]]; then size=$tagvalue3; fi
					if [[ $tag4 == "s" ]]; then size=$tagvalue4; fi
					if [[ $tag5 == "s" ]]; then size=$tagvalue5; fi
					if [[ $tag6 == "s" ]]; then size=$tagvalue6; fi
					if [[ $tag7 == "s" ]]; then size=$tagvalue7; fi
					if [[ $tag8 == "s" ]]; then size=$tagvalue8; fi

					regexsubsize="([0-9]+)"
					if [[ $SIZE =~ $regexsubsize ]]; then
						SIZE="\"${BASH_REMATCH[1]}\""
					else
						SIZE=""
					fi

					if [[ $size =~ $regexsubsize ]]; then
						size="\"${BASH_REMATCH[1]}\""
					else
						size=""
					fi


					if [[ $COLOR ]] && [[ $SIZE ]] ; then
						justtext="<font color=$COLOR size=$SIZE>"$justtext
						arraysubs[$j]=$justtext
						suffix+="</font>"
						arraysubs[-1]+=$suffix
					elif [[ $COLOR ]]; then
						justtext="<font color=$COLOR>"$justtext
						arraysubs[$j]=$justtext
						suffix+="</font>"
						arraysubs[-1]+=$suffix
					elif [[ $SIZE ]] ; then
						justtext="<font size=$SIZE>"$justtext
						arraysubs[$j]=$justtext
						suffix+="</font>"
						arraysubs[-1]+=$suffix
					fi

					if [[ $color ]] && [[ $size ]] ; then
						justtext="<font color=$color size=$size>"$justtext"</font>"
						arraysubs[$j]=$justtext
					elif [[ $color ]]; then
						justtext="<font color=$color>"$justtext"</font>"
						arraysubs[$j]=$justtext
					elif [[ $size ]] ; then
						justtext="<font size=$size>"$justtext"</font>"
						arraysubs[$j]=$justtext
					fi
				fi
			done

			((linecounter++))
			arraysrt+=("$linecounter")
			arraysrt+=("$j1 --> $j2")
			arraysrt+=("${arraysubs[@]}")
			arraysrt+=("")
		fi
	done

	IFS=$old_IFS		# restore default field separator

	# Remove an empty line at the end
	if (( ${#arraysrt[-1]} == 0 )); then
		unset arraysrt[-1]
	fi

	# Write to the txt file the contents of array.
	if (( ${#arraysrt[@]} > 2 )); then
		printf "%s\n" "${arraysrt[@]}" | iconv -f utf-8 -t $encoding > "$newfilename"
	else
		echo "Error: Not a valid sub file"; exit 1
	fi
}


srt2_sub ()
{
	if [[ $srt2sub == "pal" ]]; then ratio=1; fps=25025; firstline="{1}{1}25.000"
	elif [[ $srt2sub == "film" ]]; then ratio=1; fps=24000; firstline="{1}{1}23.976"
	elif [[ $srt2sub == "ntsc" ]]; then ratio=1; fps=30000; firstline="{1}{1}29.970"
	elif [[ $srt2sub =~ ^[0-9]+$ ]]; then ratio=1; fps=$(($srt2sub * 1001)); firstline="{1}{1}$srt2sub.000"
	elif [[ $srt2sub =~ ^[0-9]+\.[0-9]*$ ]]; then fpsint=${srt2sub%.*}; fpsdecimal=${srt2sub##*.}; decimallength=${#fpsdecimal}; if (( $decimallength == 0 )); then ratio=1; trizero="000"; firstline="{1}{1}$srt2sub$trizero"; else ratio=1$(eval printf '0%.0s' {1..$decimallength}); firstline="{1}{1}$srt2sub"; fi; fps=$(($(echo $fpsint$fpsdecimal) * 1001))
	else echo -e "Error: The srt2sub parameter only accepts the arguments pal, film, ntsc or a custom framerate.\n       Pal = 25, film = 23.976 and ntsc = 29.970"; exit 1
	fi

	if [[ "${inputfilename##*.}" != "srt" ]]; then
		echo "Warning: \"$inputfilename\" does not have '.srt' extension"
	fi


	# Check if the input file is a text
	check_file "$inputfilename"

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# The encoding must be UTF-8
	IFS=$'\n'
	encoding=$(file -b --mime-encoding $inputfilename)
	temparraysrt=( $(printf "%s\n" "${arraysrt[@]}" | iconv -f $encoding -t utf-8) )
	unset arraysrt
	arraysrt+=("${temparraysrt[@]}")
	unset temparraysrt

	# Check if the srt is OK
	newfilename="${inputfilename%.*}.sub"
	check_srt "$inputfilename" "Converting \"$inputfilename\" to \"$newfilename\"..."


	# Remove non necessary lines
	newarraysrt=()
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$(($i + 1))]} =~ $regextime ]] || [[ ${arraysrt[$(($i + 2))]} =~ $regextime ]]; then
			:
		else
			newarraysrt+=(${arraysrt[$i]})
		fi
	done


	# Assosiative array of color names converted to values used by the sub subtitles
	declare -A colornames

	colornames[indianred]="\$5C5CCD"
	colornames[lightcoral]="\$8080F0"
	colornames[salmon]="\$7280FA"
	colornames[darksalmon]="\$7A96E9"
	colornames[lightsalmon]="\$7AA0FF"
	colornames[crimson]="\$3C14DC"
	colornames[red]="\$0000FF"
	colornames[firebrick]="\$2222B2"
	colornames[darkred]="\$00008B"
	colornames[pink]="\$CBC0FF"
	colornames[lightpink]="\$C1B6FF"
	colornames[hotpink]="\$B469FF"
	colornames[deeppink]="\$9314FF"
	colornames[mediumvioletred]="\$8515C7"
	colornames[palevioletred]="\$9370DB"
	colornames[lightsalmon]="\$7AA0FF"
	colornames[coral]="\$507FFF"
	colornames[tomato]="\$4763FF"
	colornames[orangered]="\$0045FF"
	colornames[darkorange]="\$008CFF"
	colornames[orange]="\$00A5FF"
	colornames[gold]="\$00D7FF"
	colornames[yellow]="\$00FFFF"
	colornames[lightyellow]="\$E0FFFF"
	colornames[lemonchiffon]="\$CDFAFF"
	colornames[lightgoldenrodyellow]="\$D2FAFA"
	colornames[papayawhip]="\$D5EFFF"
	colornames[moccasin]="\$B5E4FF"
	colornames[peachpuff]="\$B9DAFF"
	colornames[palegoldenrod]="\$AAE8EE"
	colornames[khaki]="\$8CE6F0"
	colornames[darkkhaki]="\$6BB7BD"
	colornames[lavender]="\$FAE6E6"
	colornames[thistle]="\$D8BFD8"
	colornames[plum]="\$DDA0DD"
	colornames[violet]="\$EE82EE"
	colornames[orchid]="\$D670DA"
	colornames[fuchsia]="\$FF00FF"
	colornames[magenta]="\$FF00FF"
	colornames[mediumorchid]="\$D355BA"
	colornames[mediumpurple]="\$DB7093"
	colornames[rebeccapurple]="\$993366"
	colornames[blueviolet]="\$E22B8A"
	colornames[darkviolet]="\$D30094"
	colornames[darkorchid]="\$CC3299"
	colornames[darkmagenta]="\$8B008B"
	colornames[purple]="\$800080"
	colornames[indigo]="\$82004B"
	colornames[slateblue]="\$CD5A6A"
	colornames[darkslateblue]="\$8B3D48"
	colornames[mediumslateblue]="\$EE687B"
	colornames[greenyellow]="\$2FFFAD"
	colornames[chartreuse]="\$00FF7F"
	colornames[lawngreen]="\$00FC7C"
	colornames[lime]="\$00FF00"
	colornames[limegreen]="\$32CD32"
	colornames[palegreen]="\$98FB98"
	colornames[lightgreen]="\$90EE90"
	colornames[mediumspringgreen]="\$9AFA00"
	colornames[springgreen]="\$7FFF00"
	colornames[mediumseagreen]="\$71B33C"
	colornames[seagreen]="\$578B2E"
	colornames[forestgreen]="\$228B22"
	colornames[green]="\$008000"
	colornames[darkgreen]="\$006400"
	colornames[yellowgreen]="\$32CD9A"
	colornames[olivedrab]="\$238E6B"
	colornames[olive]="\$008080"
	colornames[darkolivegreen]="\$2F6B55"
	colornames[mediumaquamarine]="\$AACD66"
	colornames[darkseagreen]="\$8BBC8F"
	colornames[lightseagreen]="\$AAB220"
	colornames[darkcyan]="\$8B8B00"
	colornames[teal]="\$808000"
	colornames[aqua]="\$FFFF00"
	colornames[cyan]="\$FFFF00"
	colornames[lightcyan]="\$FFFFE0"
	colornames[paleturquoise]="\$EEEEAF"
	colornames[aquamarine]="\$D4FF7F"
	colornames[turquoise]="\$D0E040"
	colornames[mediumturquoise]="\$CCD148"
	colornames[darkturquoise]="\$D1CE00"
	colornames[cadetblue]="\$A09E5F"
	colornames[steelblue]="\$B48246"
	colornames[lightsteelblue]="\$DEC4B0"
	colornames[powderblue]="\$E6E0B0"
	colornames[lightblue]="\$E6D8AD"
	colornames[skyblue]="\$EBCE87"
	colornames[lightskyblue]="\$FACE87"
	colornames[deepskyblue]="\$FFBF00"
	colornames[dodgerblue]="\$FF901E"
	colornames[cornflowerblue]="\$ED9564"
	colornames[mediumslateblue]="\$EE687B"
	colornames[royalblue]="\$E16941"
	colornames[blue]="\$FF0000"
	colornames[mediumblue]="\$CD0000"
	colornames[darkblue]="\$8B0000"
	colornames[navy]="\$800000"
	colornames[midnightblue]="\$701919"
	colornames[cornsilk]="\$DCF8FF"
	colornames[blanchedalmond]="\$CDEBFF"
	colornames[bisque]="\$C4E4FF"
	colornames[navajowhite]="\$ADDEFF"
	colornames[wheat]="\$B3DEF5"
	colornames[burlywood]="\$87B8DE"
	colornames[tan]="\$8CB4D2"
	colornames[rosybrown]="\$8F8FBC"
	colornames[sandybrown]="\$60A4F4"
	colornames[goldenrod]="\$20A5DA"
	colornames[darkgoldenrod]="\$0B86B8"
	colornames[peru]="\$3F85CD"
	colornames[chocolate]="\$1E69D2"
	colornames[saddlebrown]="\$13458B"
	colornames[sienna]="\$2D52A0"
	colornames[brown]="\$2A2AA5"
	colornames[maroon]="\$000080"
	colornames[white]="\$FFFFFF"
	colornames[snow]="\$FAFAFF"
	colornames[honeydew]="\$F0FFF0"
	colornames[mintcream]="\$FAFFF5"
	colornames[azure]="\$FFFFF0"
	colornames[aliceblue]="\$FFF8F0"
	colornames[ghostwhite]="\$FFF8F8"
	colornames[whitesmoke]="\$F5F5F5"
	colornames[seashell]="\$EEF5FF"
	colornames[beige]="\$DCF5F5"
	colornames[oldlace]="\$E6F5FD"
	colornames[floralwhite]="\$F0FAFF"
	colornames[ivory]="\$F0FFFF"
	colornames[antiquewhite]="\$D7EBFA"
	colornames[linen]="\$E6F0FA"
	colornames[lavenderblush]="\$F5F0FF"
	colornames[mistyrose]="\$E1E4FF"
	colornames[gainsboro]="\$DCDCDC"
	colornames[lightgray]="\$D3D3D3"
	colornames[silver]="\$C0C0C0"
	colornames[darkgray]="\$A9A9A9"
	colornames[gray]="\$808080"
	colornames[dimgray]="\$696969"
	colornames[lightslategray]="\$998877"
	colornames[slategray]="\$908070"
	colornames[darkslategray]="\$4F4F2F"
	colornames[black]="\$000000"


	# Process the newarraysrt and at the same time create the arraysub
	IFS=$'\r'
	elementsub=()
	stringsub=()
	framesub=""
	arraysub=()
	arraysub+=($firstline)

	# Regular expression of srt color code
	regexsrtcolor="([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})"

	# Regular expressions for srt tags. They contain possible sub tags because inside the loop they co-exist
	regex_tag_i="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[bus]>)*(<font[^>]*>)*(<[bus]>)*)<i>(.*)</i>((</[bus]>)*(</font>)*(</[bus]>)*)$"
	regex_tag_b="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ius]>)*(<font[^>]*>)*(<[ius]>)*)<b>(.*)</b>((</[ius]>)*(</font>)*(</[ius]>)*)$"
	regex_tag_u="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibs]>)*(<font[^>]*>)*(<[ibs]>)*)<u>(.*)</u>((</[ibs]>)*(</font>)*(</[ibs]>)*)$"
	regex_tag_s="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibu]>)*(<font[^>]*>)*(<[ibu]>)*)<s>(.*)</s>((</[ibu]>)*(</font>)*(</[ibu]>)*)$"
	regex_tag_font_color="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_size="^(\|?({[Yy]:[ibus]+})*(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_color_size="^(\|?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"
	regex_tag_font_size_color="^(\|?({[Yy]:[ibus]+})*)((<[ibus]>)*)<font[[:blank:]]*size[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*([0-9]+)[[:blank:]]*\"?[[:blank:]]*color[[:blank:]]*=[[:blank:]]*\"?[[:blank:]]*#?[[:blank:]]*([^> \"]*)[[:blank:]]*\"?[[:blank:]]*>(.*)</font>((</[ibus]>)*)$"

	# Regular expressions for multiple tags that need to become one
	regex_merge_y_tags="^(\|?(\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?)({y:([ibus])})?({y:([ibus])})?({y:([ibus])})?({y:([ibus])})?(.*)$"
	regex_merge_Y_tags="^((\{[Cc]:[$][A-F0-9]{6}\})?(\{[Ss]:[0-9]+\})?)({Y:([ibus])})?({Y:([ibus])})?({Y:([ibus])})?({Y:([ibus])})?(.*)$"

	# Regular expression for removing the remaining srt tags
	regexremove="(.*)<[/]?([ibus]|font[^>]*)>(.*)"

	# This was put inside a function because it needs to run twice
	add_arraysub_element ()
	{
		for j in "${elementsub[@]}"; do
			# Search for "<font color ... size>" and "</font>", remove them from the text and add {C:$xxxxxx}{S:xx} if the subtitle is 1 line or {c:$xxxxxx}{s:xx} if it's more
			if [[ $j =~ $regex_tag_font_color_size ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
				srtcolor=${BASH_REMATCH[5]}
				size=${BASH_REMATCH[6]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]] && [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}{S:$size}$temptext2"
					else
						j="$temptext1{c:$subcolor}{s:$size}$temptext2"
					fi
				elif [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				elif [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size ... color>" and "</font>", remove them from the text and add {C:$xxxxxx}{S:xx} if the subtitle is 1 line or {c:$xxxxxx}{s:xx} if it's more
			if [[ $j =~ $regex_tag_font_size_color ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
				size=${BASH_REMATCH[5]}
				srtcolor=${BASH_REMATCH[6]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]] && [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}{S:$size}$temptext2"
					else
						j="$temptext1{c:$subcolor}{s:$size}$temptext2"
					fi
				elif [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				elif [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size>" and "</font>", remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
			# This runs below a second time - not a mistake
			if [[ $j =~ $regex_tag_font_size ]]; then
				size=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				if [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font color>" and "</font>", remove them from the text and add {C:$xxxxxx} if the subtitle is 1 line or {c:$xxxxxx} if it's more
			if [[ $j =~ $regex_tag_font_color ]]; then
				srtcolor=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				for colorname in "${!colornames[@]}"; do
					if [[ $colorname == ${srtcolor,,} ]]; then
						colornamefound=$colorname
						break
					fi
				done

				if [[ $colornamefound ]]; then
					subcolor=${colornames[$colornamefound]}
					unset colornamefound
				elif [[ $srtcolor =~ $regexsrtcolor ]]; then
					subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
					subcolor=${subcolor^^}
				else
					subcolor=""
				fi

				if [[ $subcolor ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{C:$subcolor}$temptext2"
					else
						j="$temptext1{c:$subcolor}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<font size>" and "</font>", remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
			if [[ $j =~ $regex_tag_font_size ]]; then
				size=${BASH_REMATCH[8]}
				temptext1=${BASH_REMATCH[1]}
				temptext2=${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

				if [[ $size ]]; then
					if [[ ${#elementsub[@]} == 1 ]]; then
						j="$temptext1{S:$size}$temptext2"
					else
						j="$temptext1{s:$size}$temptext2"
					fi
				else
					j="$temptext1$temptext2"
				fi
			fi

			# Search for "<i>" and "</i>", remove them from the text and add {Y:i} if the subtitle is 1 line or {y:i} if it's more
			if [[ $j =~ $regex_tag_i ]] && ! [[ ${BASH_REMATCH[10]} == *"<i>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</i>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:i}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:i}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<b>" and "</b>", remove them from the text and add {Y:b} if the subtitle is 1 line or {y:b} if it's more
			if [[ $j =~ $regex_tag_b ]] && ! [[ ${BASH_REMATCH[10]} == *"<b>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</b>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:b}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:b}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<u>" and "</u>", remove them from the text and add {Y:u} if the subtitle is 1 line or {y:u} if it's more
			if [[ $j =~ $regex_tag_u ]] && ! [[ ${BASH_REMATCH[10]} == *"<u>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</u>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:u}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:u}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Search for "<s>" and "</s>", remove them from the text and add {Y:s} if the subtitle is 1 line or {y:s} if it's more
			if [[ $j =~ $regex_tag_s ]] && ! [[ ${BASH_REMATCH[10]} == *"<s>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</s>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:s}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				else
					j="${BASH_REMATCH[1]}{y:s}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
				fi
			fi

			# Merge multiple y tags
			if [[ $j =~ $regex_merge_y_tags ]] && [[ ${BASH_REMATCH[4]} ]]; then
				j="${BASH_REMATCH[1]}{y:${BASH_REMATCH[5]}${BASH_REMATCH[7]}${BASH_REMATCH[9]}${BASH_REMATCH[11]}}${BASH_REMATCH[12]}"
			fi

			stringsub=${stringsub:+$stringsub}$j
		done

		# Search for "<s>" and "</s>" that enclose all lines, remove them from the text and add {Y:s}
		if [[ $stringsub =~ $regex_tag_s ]] && ! [[ ${BASH_REMATCH[10]} == *"<s>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</s>"* ]]; then
			stringsub="{Y:s}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<u>" and "</u>" that enclose all lines, remove them from the text and add {Y:u}
		if [[ $stringsub =~ $regex_tag_u ]] && ! [[ ${BASH_REMATCH[10]} == *"<u>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</u>"* ]]; then
			stringsub="{Y:u}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<b>" and "</b>" that enclose all lines, remove them from the text and add {Y:b}
		if [[ $stringsub =~ $regex_tag_b ]] && ! [[ ${BASH_REMATCH[10]} == *"<b>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</b>"* ]]; then
			stringsub="{Y:b}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<i>" and "</i>" that enclose all lines, remove them from the text and add {Y:i}
		if [[ $stringsub =~ $regex_tag_i ]] && ! [[ ${BASH_REMATCH[10]} == *"<i>"* ]] && ! [[ ${BASH_REMATCH[10]} == *"</i>"* ]]; then
			stringsub="{Y:i}${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[10]}${BASH_REMATCH[11]}"
		fi

		# Search for "<font color ... size>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}{S:xx}
		if [[ $stringsub =~ $regex_tag_font_color_size ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
			srtcolor=${BASH_REMATCH[5]}
			size=${BASH_REMATCH[6]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]] && [[ $size ]]; then
				stringsub="{C:$subcolor}{S:$size}$temptext"
			elif [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			elif [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size ... color>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}{S:xx}
		if [[ $stringsub =~ $regex_tag_font_size_color ]] && ! [[ ${BASH_REMATCH[7]} == *"<font"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</font>"* ]]; then
			size=${BASH_REMATCH[5]}
			srtcolor=${BASH_REMATCH[6]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}

			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]] && [[ $size ]]; then
				stringsub="{C:$subcolor}{S:$size}$temptext"
			elif [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			elif [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size>" and "</font>" that enclose all lines, remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
		# This runs below a second time - not a mistake
		if [[ $stringsub =~ $regex_tag_font_size ]]; then
			size=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

			if [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font color>" and "</font>" that enclose all lines, remove them from the text and add {C:$xxxxxx}
		if [[ $stringsub =~ $regex_tag_font_color ]]; then
			srtcolor=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}
			for colorname in "${!colornames[@]}"; do
				if [[ $colorname == ${srtcolor,,} ]]; then
					colornamefound=$colorname
					break
				fi
			done

			if [[ $colornamefound ]]; then
				subcolor=${colornames[$colornamefound]}
				unset colornamefound
			elif [[ $srtcolor =~ $regexsrtcolor ]]; then
				subcolor="\$${BASH_REMATCH[3]}${BASH_REMATCH[2]}${BASH_REMATCH[1]}"
				subcolor=${subcolor^^}
			else
				subcolor=""
			fi

			if [[ $subcolor ]]; then
				stringsub="{C:$subcolor}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Search for "<font size>" and "</font>" that enclose all lines, remove them from the text and add {S:xx} if the subtitle is 1 line or {s:xx} if it's more
		if [[ $stringsub =~ $regex_tag_font_size ]]; then
			size=${BASH_REMATCH[8]}
			temptext=${BASH_REMATCH[1]}${BASH_REMATCH[6]}${BASH_REMATCH[9]}${BASH_REMATCH[10]}

			if [[ $size ]]; then
				stringsub="{S:$size}$temptext"
			else
				stringsub="$temptext"
			fi
		fi

		# Merge multiple Y tags
		if [[ $stringsub =~ $regex_merge_Y_tags ]] && [[ ${BASH_REMATCH[4]} ]]; then
			stringsub="${BASH_REMATCH[1]}{Y:${BASH_REMATCH[5]}${BASH_REMATCH[7]}${BASH_REMATCH[9]}${BASH_REMATCH[11]}}${BASH_REMATCH[12]}"
		fi

		# Remove the remaining srt tags
		if [[ $srt2sub_delsrttags ]]; then
			while [[ $stringsub =~ $regexremove ]]; do
				stringsub=${BASH_REMATCH[1]}${BASH_REMATCH[3]}
			done
		fi

		arraysub+=($framesub$stringsub)
	}

	for ((i=0; i<${#newarraysrt[@]}; i++)); do
		line=${newarraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			framesstart=$(($fps * $p1 / (($ratio * 1001000))))
			framesend=$(($fps * $p2 / (($ratio * 1001000))))

			add_arraysub_element

			unset elementsub
			stringsub=""

			framesub="{$framesstart}{$framesend}"

		elif [[ $elementsub ]]; then
			elementsub+=(\|$line)
		else
			elementsub+=($line)
		fi
	done

	# Run for the last subtitle
	add_arraysub_element

	# Write to the txt file the contents of array.
	if (( ${#arraysub[@]} >= 1 )); then
		printf "%s\r\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$newfilename"
	else
		echo "Error: Not a valid srt file"; exit 1
	fi
	IFS=$old_IFS		# restore default field separator
}


join_srt ()
{
	if [[ "${inputfilename##*.}" != "srt" ]]; then
		echo "Warning: \"$inputfilename\" does not have '.srt' extension"
	fi

	if [[ "${joinsrt##*.}" != "srt" ]]; then
		echo "Warning: \"$joinsrt\" does not have '.srt' extension"
	fi

	# Check if the input file is a text
	check_file "$joinsrt"

	# Read text file to arraysrt
	read_srt "$joinsrt"

	# Check if the srt is OK
	check_srt "$joinsrt"

	# Create arraysrtjoin from arraysrt
	arraysrtjoin+=("${arraysrt[@]}")


	# Check if the input file is a text
	check_file "$inputfilename"

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename"


	# Add an empty line
	arraysrt+=("")

	if ! [[ $jointime ]]; then
		echo "Joining \"$inputfilename\" with \"$joinsrt\"..."
		# Re-create the second subtitle array with new counter
		for ((i=0; i<=${#arraysrtjoin[@]}; i++)); do
			if [[ ${arraysrtjoin[$((i+1))]} =~ $regextime ]] && [[ ${arraysrtjoin[$i]} =~ ^([0-9]+) ]]; then
				((subcounter++))
				arraysrtjoin[$i]="$subcounter"
			fi
		done
	else
		# Calculate the time of the end time of the last subtitle of the first file
		for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
			line=${arraysrt[$i]}

			if [[ $line =~ $regextime ]]; then
				h2b="${BASH_REMATCH[5]}"
				m2b="${BASH_REMATCH[6]}"
				s2b="${BASH_REMATCH[7]}"
				f2b="${BASH_REMATCH[8]}"

				break
			fi
		done

		# Time in milliseconds of the end time of the last subtitle of the first file
		p2b=$(($(($((10#$h2b)) * 3600000)) + $(($((10#$m2b)) * 60000)) + $(($((10#$s2b)) * 1000)) + $((10#$f2b))))


		# Calculate the time to shift the second subtitle
		regexjoin="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

		if [[ $jointime =~ $regexjoin ]]; then
			h="${BASH_REMATCH[1]}"
			m="${BASH_REMATCH[2]}"
			s="${BASH_REMATCH[3]}"
			f="${BASH_REMATCH[4]}"
		else
			echo "Error: Syntax must be like 'hh:mm:ss,fff'"; exit 1
		fi

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
			echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
		fi

		# Time in milliseconds of jointime
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


		# Compare jointime with the end time of the last subtitle of the first file
		if ((p < p2b)); then
			echo "Error: The duration of the first video (-J parameter) cannot be less than the first subtitle"; exit 1
		else
			echo "Joining \"$inputfilename\" with \"$joinsrt\"..."
		fi


		# Process the array of the second subtitle
		for ((i=0; i<=${#arraysrtjoin[@]}; i++)); do
			line=${arraysrtjoin[$i]}

			if [[ $line =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				h2="${BASH_REMATCH[5]}"
				m2="${BASH_REMATCH[6]}"
				s2="${BASH_REMATCH[7]}"
				f2="${BASH_REMATCH[8]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
				p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

				p1_new=$(($p1 + $p))
				p2_new=$(($p2 + $p))

				j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
				j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

				line_new="$j1 --> $j2"

				arraysrtjoin[$i]=$line_new
			fi
		done

		# Re-create the second subtitle array with new counter
		for ((i=0; i<=${#arraysrtjoin[@]}; i++)); do
			if [[ ${arraysrtjoin[$((i+1))]} =~ $regextime ]] && [[ ${arraysrtjoin[$i]} =~ ^([0-9]+) ]]; then
				((subcounter++))
				arraysrtjoin[$i]="$subcounter"
			fi
		done
	fi


	# Add the second array to the first
	arraysrt+=("${arraysrtjoin[@]}")

	# Write to the txt file the contents of array.
	basename=${inputfilename%.*}
	j="_join.srt"
	printf "%s\n" "${arraysrt[@]}" > "$basename$j"

	unix2dos -q "$basename$j"
}


split_srt ()
{
	# Check if the input file is a text
	check_file "$inputfilename"

	# Read text file to arraysrt
	read_srt "$inputfilename"

	# Check if the srt is OK
	check_srt "$inputfilename" "Splitting \"$inputfilename\"..."


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in milliseconds of the start time of the first subtitle
	p1a=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	p1b=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Initialize the variables
	splitsubfound=""
	split2counter=0
	arraysrtsplit1=()
	arraysrtsplit2=()

	# Calculate the time to split the subtitle
	regexsplit1="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"
	regexsplit2="^([+-]?)([0-9]+)$"
	regexsplit3="^([+-]?)([0-9]+)[:]([0-9]+)[t]$"
	regexsplit4="^([+-]?)([0-9]+)[:]([0-9]+)[n]$"

	if [[ $splitsrt =~ $regexsplit1 ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"

		if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
			echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
		fi

		# Time in milliseconds to split the subtitle
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
		if [[ $sign == "-" ]]; then
			p=$(($p1b - $p))
		fi

		if ((p < p1a)); then
			echo "Error: Split time cannot precede the start time of the first subtitle."; exit 1
		fi

		if ((p > p1b)); then
			echo "Error: Split time cannot exceed the start time of the last subtitle."; exit 1
		fi

		# Find the subtitle to make the split
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

				if ((p1 >= p)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splitsrt =~ $regexsplit2 ]]; then
		sign="${BASH_REMATCH[1]}"
		splitinteger="${BASH_REMATCH[2]}"

		if [[ $sign == "-" ]]; then
			splitinteger=$(($subcounter - $splitinteger))
		fi

		# Check if the given integer is OK
		if ((splitinteger == 0)) || ((splitinteger > ((subcounter-1)))); then
			echo "Error: The number of subtitles in the file are $subcounter. The given integer must be between or equal to 1 and $((subcounter-1))."; exit 1
		fi

		# Create the two new subtitle arrays
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]] && [[ $line =~ ^([0-9]+) ]]; then
				if ((line > splitinteger)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splitsrt =~ $regexsplit3 ]]; then
		sign="${BASH_REMATCH[1]}"
		numerator="${BASH_REMATCH[2]}"
		denominator="${BASH_REMATCH[3]}"

		if ((numerator == 0)) || ((denominator == 0)) || ((numerator >= denominator)); then
			echo "Error: The numerator must be less than the denominator and both must not be 0."; exit 1
		fi

		# Time in milliseconds to split the subtitle
		if [[ $sign == "-" ]]; then
			p=$((p1b*((denominator - numerator))/denominator))
		else
			p=$((p1b*numerator/denominator))
		fi

		if ((p < p1a)); then
			echo "Error: Split time cannot precede the start time of the first subtitle."; exit 1
		fi

		# Find the subtitle to make the split
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]]; then
				h1="${BASH_REMATCH[1]}"
				m1="${BASH_REMATCH[2]}"
				s1="${BASH_REMATCH[3]}"
				f1="${BASH_REMATCH[4]}"

				p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))

				if ((p1 >= p)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	elif [[ $splitsrt =~ $regexsplit4 ]]; then
		sign="${BASH_REMATCH[1]}"
		numerator="${BASH_REMATCH[2]}"
		denominator="${BASH_REMATCH[3]}"

		if ((numerator == 0)) || ((denominator == 0)) || ((numerator >= denominator)); then
			echo "Error: The numerator must be less than the denominator and both must not be 0."; exit 1
		fi

		if [[ $sign == "-" ]]; then
			if ((subcounter%2 == 1)) && ((denominator/numerator == 2)); then
				splitinteger=$((1 + subcounter*((denominator - numerator))/denominator))
			else
				splitinteger=$((subcounter*((denominator - numerator))/denominator))
			fi
		else
			if ((subcounter%2 == 1)) && ((denominator/numerator == 2)); then
				splitinteger=$((1 + subcounter*numerator/denominator))
			else
				splitinteger=$((subcounter*numerator/denominator))
			fi
		fi

		# Check if the integer is OK
		if ((splitinteger == 0)); then
			echo "Error: The fraction is too small. Exiting..."; exit 1
		fi

		# Create the two new subtitle arrays
		for ((i=0; i<=${#arraysrt[@]}-1; i++)); do
			line=${arraysrt[$i]}
			nextline=${arraysrt[((i+1))]}

			if ! [[ $splitsubfound ]] && [[ $nextline =~ $regextime ]] && [[ $line =~ ^([0-9]+) ]]; then
				if ((line > splitinteger)); then
					splitsubfound="True"
				fi
			fi

			if ! [[ $splitsubfound ]]; then
				arraysrtsplit1[$i]=$line
			else
				arraysrtsplit2[$split2counter]=$line
				((split2counter++))
			fi
		done
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff' or '(+/-)SUB_INTEGER' or '(+/-)INTEGER:INTEGERt' or '(+/-)INTEGER:INTEGERn'"; exit 1
	fi


	# Re-create the second subtitle array with new counter
	subcounter=0
	for ((i=0; i<=${#arraysrtsplit2[@]}-1; i++)); do
		if [[ ${arraysrtsplit2[((i+1))]} =~ $regextime ]] && [[ ${arraysrtsplit2[$i]} =~ ^([0-9]+) ]]; then
			((subcounter++))
			arraysrtsplit2[$i]="$subcounter"
		fi
	done


	# Remove an empty line at the end
	if (( ${#arraysrtsplit1[-1]} == 0 )); then
		unset arraysrtsplit1[-1]
	fi


	# Write to the txt file the contents of the two arrays.
	basename=${inputfilename%.*}
	firstfile="_1.srt"
	secondfile="_2.srt"
	printf "%s\n" "${arraysrtsplit1[@]}" > "$basename$firstfile"
	printf "%s\n" "${arraysrtsplit2[@]}" > "$basename$secondfile"

	unix2dos -q "$basename$firstfile"
	unix2dos -q "$basename$secondfile"


	# If -X (splittime) exists:
	unset arraysrt
	if [[ $splittime ]]; then
		# Find the first subtitle time of the second file
		for ((i=0; i<=${#arraysrtsplit2[@]}; i++)); do
			line=${arraysrtsplit2[$i]}

			if [[ $line =~ $regextime ]]; then
				h1a="${BASH_REMATCH[1]}"
				m1a="${BASH_REMATCH[2]}"
				s1a="${BASH_REMATCH[3]}"
				f1a="${BASH_REMATCH[4]}"

				break
			fi
		done

	shifttime="-$h1a:$m1a:$s1a,$f1a"
	inputfilename="$basename$secondfile"
	shift_time
	unset shifttime
	fi
}


if [[ $inputfilename ]]; then
	if [[ $shifttime ]]; then
		shift_time
	elif [[ $pal2ntsc ]]; then
		change_fps
	elif [[ $ntsc2pal ]]; then
		change_fps
	elif [[ $adjustfirst ]]; then
		adjust_time
	elif [[ $adjustonlyfirst ]]; then
		adjust_time_v2
	elif [[ $adjustonlylast ]]; then
		adjust_time_v2
	elif [[ $synchronizefile ]]; then
		synchronize_with_file
	elif [[ $replace1 ]]; then
		replace_text
	elif [[ $replace3 ]]; then
		replace_text
	elif [[ $sub2srt ]]; then
		sub2_srt
	elif [[ $srt2sub ]]; then
		srt2_sub
	elif [[ $joinsrt ]]; then
		join_srt
	elif [[ $splitsrt ]]; then
		split_srt
	fi
	exit 0
fi
