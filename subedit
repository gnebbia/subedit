#!/usr/bin/bash


#	Copyright 2016 George Savvidis, Odysseas Raftopoulos

#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 2 of the License, or
#	(at your option) any later version.

#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.

#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Help
get_help ()
{
	echo ""
	echo "$(tput setaf 6)NAME $(tput sgr0)"
	echo "    subedit"
	echo ""
	echo "$(tput setaf 6)DESCRIPTION $(tput sgr0)"
	echo "    Command line subtitle editor."
	echo ""
	echo "$(tput setaf 6)PARAMETERS $(tput sgr0)"
	echo "    -i        Input file. Takes value of a fullpath or a filename in your working directory."
	echo "    -s        Shift time. Takes value of type 'hh:mm:ss:fff'."
	echo "    -p        Switch. Changes the fps from NTSC to PAL."
	echo "    -n        Switch. Changes the fps from PAL to NTSC."
	echo "    -a        Adjust time. Takes value of type '(+/-)hh:mm:ss,fff_(+/-)hh:mm:ss,fff'."
	echo "    -h        Display this info and exit."
	exit
}


# If no parameter is given then exit
if ( ! getopts ":i:s:pna:y:e:E:h" opt); then
	echo "Try 'subedit -h' for more information."; exit 1;
fi

# Processing parameters
while getopts ":i:s:pna:y:e:E:h" parameter; do
	case "$parameter" in
		i) inputfilename=$OPTARG ;;
		s) shifttime=$OPTARG ;;
		p) ntsc2pal="True" ;;
		n) pal2ntsc="True" ;;
		a)	eval "adjustfirst=\$$((OPTIND-1))"
			eval "adjustlast=\$$((OPTIND))"
			((OPTIND++)) ;;
		y) synchronizefile=$OPTARG ;;
		e)	eval "replace1=\$$((OPTIND-1))"
			eval "replace2=\$$((OPTIND))"
			((OPTIND++)) ;;
		E)	eval "replace3=\$$((OPTIND-1))"
			eval "replace4=\$$((OPTIND))"
			((OPTIND++)) ;;
		h) get_help ;;
		?) echo -e "Parameter -$OPTARG is unknown or an argument is missing.\nTry 'subedit -h' for more information."; exit 1 ;;
	esac
done


### Main functions
shift_time ()
{
	# Calculate the time to move the subs
	regexshift="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $shifttime =~ $regexshift ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi

	echo "Shifting time of \"$inputfilename\" by $shifttime..."

	p=$sign$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Process the array
	regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p1 + $p))
			p2_new=$(($p2 + $p))

			if (( $p1_new < 0 )); then
				echo "Error: Negative time not allowed. Check the shifting value."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


change_fps ()
{
	if [[ $pal2ntsc ]]; then
		echo "Changing fps of \"$inputfilename\" from PAL (25) to NTSC (23.976 or 29.970)..."
	elif [[ $ntsc2pal ]]; then
		echo "Changing fps of \"$inputfilename\" from NTSC (23.976 or 29.970) to PAL (25)..."
	fi


	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Process the array
	regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			if [[ $pal2ntsc ]]; then
				p1_new=$(($p1 * 1001 / 960))
				p2_new=$(($p2 * 1001 / 960))
			elif [[ $ntsc2pal ]]; then
				p1_new=$(($p1 * 960 / 1001))
				p2_new=$(($p2 * 960 / 1001))
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


adjust_time ()
{
	# Calculate the time to move the subs
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	if [[ $adjustfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'"; exit 1
	fi

	if [[ $adjustlast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi

	echo "Adjusting time of \"$inputfilename\"..."


	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Find the first and last subtitle time
	regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in miliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in miliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Calculate the NEW first and last subtitle
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $p >= $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; exit 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


synchronize_with_file ()
{
	# Read file to synchronize to
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$synchronizefile"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Find the first and last subtitle time of the file to synchronize to
	regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h="${BASH_REMATCH[1]}"
			m="${BASH_REMATCH[2]}"
			s="${BASH_REMATCH[3]}"
			f="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h_="${BASH_REMATCH[1]}"
			m_="${BASH_REMATCH[2]}"
			s_="${BASH_REMATCH[3]}"
			f_="${BASH_REMATCH[4]}"

			break
		fi
	done

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: The first or last subtitle time of the subtitle you want to synchronize with, is invalid."; exit 1
	fi

	# Calculate the NEW first and last subtitle
	p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))

	if (( $p >= $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; exit 1
	fi

	echo "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."


	unix2dos -q "$inputfilename"

	# Read text file to array
	arraysrt=()
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in miliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in miliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


replace_text ()
{
	if [[ $replace3 ]]; then
		replace1=$replace3
		replace2=$replace4
	fi

	# Define forbitten and allowed regex
	regexforbittensynbols="^[0-9<>\/:{}\$=#-,]+$"
	regexallowedtimes="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframes="^\{[0-9]+\}\{[0-9]+\}$"
	regexallowedtime="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframe="^\{[0-9]+\}$"

	if ! [[  $replace1 =~  $regexallowedtimes ]] && ! [[  $replace1 =~  $regexallowedframes ]] && ! [[  $replace1 =~  $regexallowedtime ]] && ! [[  $replace1 =~  $regexallowedframe ]] && [[ $replace1 =~ $regexforbittensynbols ]]; then
		echo "Error: You cannot replace this"; exit 1
	fi

	echo "Replacing \"$replace1\" with \"$replace2\" in file \"$inputfilename\""

	if [[ $replace3 ]]; then
		sed -i s"/$replace1/$replace2/g" "$inputfilename"
	else
		sed -i s"/$replace1/$replace2/ig" "$inputfilename"
	fi
}


if [[ $inputfilename ]]; then
	if [[ $shifttime ]]; then
		shift_time
	elif [[ $pal2ntsc ]]; then
		change_fps
	elif [[ $ntsc2pal ]]; then
		change_fps
	elif [[ $adjustfirst ]]; then
		adjust_time
	elif [[ $synchronizefile ]]; then
		synchronize_with_file
	elif [[ $replace1 ]]; then
		replace_text
	elif [[ $replace3 ]]; then
		replace_text
	fi
	exit 0
fi
