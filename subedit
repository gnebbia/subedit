#!/usr/bin/bash


#	Copyright 2016-2017 George Savvidis, Odysseas Raftopoulos

#	This program is free software: you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation, either version 2 of the License, or
#	(at your option) any later version.

#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.

#	You should have received a copy of the GNU General Public License
#	along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Help
get_help ()
{
	echo ""
	echo "$(tput setaf 6)NAME $(tput sgr0)"
	echo "    subedit"
	echo ""
	echo "$(tput setaf 6)DESCRIPTION $(tput sgr0)"
	echo "    Command line subtitle editor."
	echo ""
	echo "$(tput setaf 6)PARAMETERS $(tput sgr0)"
	echo "    -i        Input file. Takes value of a fullpath or a filename in your working directory."
	echo "    -s        Shift time. Takes value of type 'hh:mm:ss:fff'."
	echo "    -p        Switch. Changes the fps from NTSC to PAL."
	echo "    -n        Switch. Changes the fps from PAL to NTSC."
	echo "    -a        Adjust time. Takes value of type '(+/-)hh:mm:ss,fff_(+/-)hh:mm:ss,fff'."
	echo "    -h        Display this info and exit."
	exit
}


# If no parameter is given then exit
if ( ! getopts ":i:s:pna:y:e:E:t:u:h" opt); then
	echo "Try 'subedit -h' for more information."; exit 1;
fi

# Processing parameters
while getopts ":i:s:pna:y:e:E:t:u:h" parameter; do
	case "$parameter" in
		i) inputfilename=$OPTARG ;;
		s) shifttime=$OPTARG ;;
		p) ntsc2pal="True" ;;
		n) pal2ntsc="True" ;;
		a)	eval "adjustfirst=\$$((OPTIND-1))"
			eval "adjustlast=\$$((OPTIND))"
			((OPTIND++)) ;;
		y) synchronizefile=$OPTARG ;;
		e)	eval "replace1=\$$((OPTIND-1))"
			eval "replace2=\$$((OPTIND))"
			((OPTIND++)) ;;
		E)	eval "replace3=\$$((OPTIND-1))"
			eval "replace4=\$$((OPTIND))"
			((OPTIND++)) ;;
		t) sub2srt=$OPTARG ;;
		u) srt2sub=$OPTARG ;;
		h) get_help ;;
		?) echo -e "Parameter -$OPTARG is unknown or an argument is missing.\nTry 'subedit -h' for more information."; exit 1 ;;
	esac
done


### Main functions
shift_time ()
{
	# Calculate the time to move the subs
	regexshift="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])$"

	if [[ $shifttime =~ $regexshift ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi

	echo "Shifting time of \"$inputfilename\" by $shifttime..."

	p=$sign$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))


	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Process the array
	regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p1 + $p))
			p2_new=$(($p2 + $p))

			if (( $p1_new < 0 )); then
				echo "Error: Negative time not allowed. Check the shifting value."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


change_fps ()
{
	if [[ $pal2ntsc ]]; then
		echo "Changing fps of \"$inputfilename\" from PAL (25) to NTSC (23.976 or 29.970)..."
	elif [[ $ntsc2pal ]]; then
		echo "Changing fps of \"$inputfilename\" from NTSC (23.976 or 29.970) to PAL (25)..."
	fi


	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Process the array
	regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			if [[ $pal2ntsc ]]; then
				p1_new=$(($p1 * 1001 / 960))
				p2_new=$(($p2 * 1001 / 960))
			elif [[ $ntsc2pal ]]; then
				p1_new=$(($p1 * 960 / 1001))
				p2_new=$(($p2 * 960 / 1001))
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


adjust_time ()
{
	# Calculate the time to move the subs
	regexadjust="^([+-]?)([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	if [[ $adjustfirst =~ $regexadjust ]]; then
		sign="${BASH_REMATCH[1]}"
		h="${BASH_REMATCH[2]}"
		m="${BASH_REMATCH[3]}"
		s="${BASH_REMATCH[4]}"
		f="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'"; exit 1
	fi

	if [[ $adjustlast =~ $regexadjust ]]; then
		sign_="${BASH_REMATCH[1]}"
		h_="${BASH_REMATCH[2]}"
		m_="${BASH_REMATCH[3]}"
		s_="${BASH_REMATCH[4]}"
		f_="${BASH_REMATCH[5]}"
	else
		echo "Error: Syntax must be like '(+/-)hh:mm:ss,fff (+/-)hh:mm:ss,fff'"; exit 1
	fi

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: Minutes and seconds must take a value of less than 60"; exit 1
	fi

	echo "Adjusting time of \"$inputfilename\"..."


	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Find the first and last subtitle time
	regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Calculate the NEW first and last subtitle
	if [[ $sign ]]; then
		p=$(($pa $sign $(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))))
	else
		p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	fi

	if [[ $sign_ ]]; then
		p_=$(($pb $sign_ $(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))))
	else
		p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))
	fi


	if (( $p >= $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; exit 1
	fi


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


synchronize_with_file ()
{
	# Read file to synchronize to
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$synchronizefile"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Find the first and last subtitle time of the file to synchronize to
	regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h="${BASH_REMATCH[1]}"
			m="${BASH_REMATCH[2]}"
			s="${BASH_REMATCH[3]}"
			f="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h_="${BASH_REMATCH[1]}"
			m_="${BASH_REMATCH[2]}"
			s_="${BASH_REMATCH[3]}"
			f_="${BASH_REMATCH[4]}"

			break
		fi
	done

	if (( 10#$m >= 60 )) || (( 10#$s >= 60 )) || (( 10#$m_ >= 60 )) || (( 10#$s_ >= 60 )); then
		echo "Error: The first or last subtitle time of the subtitle you want to synchronize with, is invalid."; exit 1
	fi

	# Calculate the NEW first and last subtitle
	p=$(($(($((10#$h)) * 3600000)) + $(($((10#$m)) * 60000)) + $(($((10#$s)) * 1000)) + $((10#$f))))
	p_=$(($(($((10#$h_)) * 3600000)) + $(($((10#$m_)) * 60000)) + $(($((10#$s_)) * 1000)) + $((10#$f_))))

	if (( $p >= $p_ )); then
		echo "Error: The first subtitle cannot start after the last subtitle"; exit 1
	fi

	echo "Synchronizing \"$inputfilename\" with \"$synchronizefile\"..."


	unix2dos -q "$inputfilename"

	# Read text file to array
	arraysrt=()
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	for line in $(cat "$inputfilename"); do
		arraysrt+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	# Find the first and last subtitle time
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1a="${BASH_REMATCH[1]}"
			m1a="${BASH_REMATCH[2]}"
			s1a="${BASH_REMATCH[3]}"
			f1a="${BASH_REMATCH[4]}"

			break
		fi
	done

	for ((i=-1; i>=-${#arraysrt[@]}; i--)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1b="${BASH_REMATCH[1]}"
			m1b="${BASH_REMATCH[2]}"
			s1b="${BASH_REMATCH[3]}"
			f1b="${BASH_REMATCH[4]}"

			break
		fi
	done

	# Time in milliseconds of the start time of the first subtitle
	pa=$(($(($((10#$h1a)) * 3600000)) + $(($((10#$m1a)) * 60000)) + $(($((10#$s1a)) * 1000)) + $((10#$f1a))))

	# Time in milliseconds of the start time of the last subtitle
	pb=$(($(($((10#$h1b)) * 3600000)) + $(($((10#$m1b)) * 60000)) + $(($((10#$s1b)) * 1000)) + $((10#$f1b))))


	# Process the array
	diff1=$(($p_ - $p))
	diff2=$(($pb - $pa))

	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		line=${arraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			p1_new=$(($p + $diff1 * (($p1 - $pa)) / $diff2))
			p2_new=$(($p + $diff1 * (($p2 - $pa)) / $diff2))

			if (( $p1_new < 0 )); then
				echo "Error: Negative time not allowed. Check the adjusting values."; exit 1
			fi

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1_new / 3600000)) $(($(($p1_new % 3600000)) / 60000)) $(($(($p1_new % 60000)) / 1000)) $(($p1_new % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2_new / 3600000)) $(($(($p2_new % 3600000)) / 60000)) $(($(($p2_new % 60000)) / 1000)) $(($p2_new % 1000)))

			line_new="$j1 --> $j2"

			arraysrt[$i]=$line_new
		fi
	done

	# Write to the txt file the contents of array.
	printf "%s\n" "${arraysrt[@]}" > "$inputfilename"
}


replace_text ()
{
	if [[ $replace3 ]]; then
		replace1=$replace3
		replace2=$replace4
	fi

	# Define forbitten and allowed regex
	regexforbittensynbols="^[0-9<>\/:{}\$=#-,]+$"
	regexallowedtimes="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9] --> [0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframes="^\{[0-9]+\}\{[0-9]+\}$"
	regexallowedtime="^[0-9][0-9]:[0-9][0-9]:[0-9][0-9],[0-9][0-9][0-9]$"
	regexallowedframe="^\{[0-9]+\}$"

	if ! [[  $replace1 =~  $regexallowedtimes ]] && ! [[  $replace1 =~  $regexallowedframes ]] && ! [[  $replace1 =~  $regexallowedtime ]] && ! [[  $replace1 =~  $regexallowedframe ]] && [[ $replace1 =~ $regexforbittensynbols ]]; then
		echo "Error: You cannot replace this"; exit 1
	fi

	echo "Replacing \"$replace1\" with \"$replace2\" in file \"$inputfilename\""

	if [[ $replace3 ]]; then
		sed -i s"/$replace1/$replace2/g" "$inputfilename"
	else
		sed -i s"/$replace1/$replace2/ig" "$inputfilename"
	fi
}


sub2_srt ()
{
	if [[ $sub2srt == "pal" ]]; then ratio=1; fps=25025
	elif [[ $sub2srt == "film" ]]; then ratio=1; fps=24000
	elif [[ $sub2srt == "ntsc" ]]; then ratio=1; fps=30000
	elif [[ $sub2srt =~ ^[0-9]+$ ]]; then ratio=1; fps=$(($sub2srt * 1001))
	elif [[ $sub2srt =~ ^[0-9]+\.[0-9]*$ ]]; then fpsint=${sub2srt%.*}; fpsdecimal=${sub2srt##*.}; decimallength=${#fpsdecimal}; if (( $decimallength == 0 )); then ratio=1; else ratio=1$(eval printf '0%.0s' {1..$decimallength}); fi; fps=$(($(echo $fpsint$fpsdecimal) * 1001))
	else echo -e "Error: The sub2srt parameter only accepts the arguments pal, film, ntsc or a custom framerate.\n       Pal = 25, film = 23.976 and ntsc = 29.970"; exit 1
	fi

	if [[ "${inputfilename##*.}" != "sub" ]]; then
		echo "Warning: \"$inputfilename\" does not have '.sub' extension"
	fi


	unix2dos -q "$inputfilename"

	# Read text file to array
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	encoding=$(file -b --mime-encoding $inputfilename)
	for line in $(iconv -f $encoding -t utf-8 "$inputfilename"); do
		arraysub+=($line)
	done

	IFS=$old_IFS		# restore default field separator


	arraysrt=()

	# Process the arraysub and at the same time create the arraysrt
	regexsub="^\{([0-9]+)\}\{([0-9]+)\}(.+)$"
	regexsub1="^\{[1]\}\{[1]\}(.+)$"

	linecounter=0
	IFS=$'|'			# new field separator, the new line character in sub file

	for ((i=0; i<=${#arraysub[@]}-1; i++)); do
		line=${arraysub[$i]}

		if ! [[ $line =~ $regexsub1 ]] && [[ $line =~ $regexsub ]]; then
			framesstart="${BASH_REMATCH[1]}"
			framesend="${BASH_REMATCH[2]}"
			subs="${BASH_REMATCH[3]}"

			p1=$((1001000 * $ratio * $framesstart / $fps))
			p2=$((1001000 * $ratio * $framesend / $fps))

			j1=$(printf "%02d:%02d:%02d,%03d" $(($p1 / 3600000)) $(($(($p1 % 3600000)) / 60000)) $(($(($p1 % 60000)) / 1000)) $(($p1 % 1000)))
			j2=$(printf "%02d:%02d:%02d,%03d" $(($p2 / 3600000)) $(($(($p2 % 3600000)) / 60000)) $(($(($p2 % 60000)) / 1000)) $(($p2 % 1000)))

			read -r -a arraysubs <<< "$subs"

			((linecounter++))
			arraysrt+=("$linecounter")
			arraysrt+=("$j1 --> $j2")
			arraysrt+=("${arraysubs[@]}")
			arraysrt+=("")
		elif [[ $line == "" ]] || (( ${#line} == 1 )) || [[ $line =~ $regexsub1 ]]; then
			:
		else
			echo "Warning: There's something wrong with line $(($i+1)) in the sub file"
		fi
	done

	IFS=$old_IFS		# restore default field separator


	# Write to the txt file the contents of array.
	if (( ${#arraysrt[@]} > 2 )); then
		newfilename="${inputfilename%.*}.srt"
		echo "Converting \"$inputfilename\" to \"$newfilename\"..."
		printf "%s\n" "${arraysrt[@]}" | iconv -f utf-8 -t $encoding > "$newfilename"
	else
		echo "Error: Not a valid sub file"; exit 1
	fi
}


srt2_sub ()
{
	if [[ $srt2sub == "pal" ]]; then ratio=1; fps=25025; firstline="{1}{1}25.000"
	elif [[ $srt2sub == "film" ]]; then ratio=1; fps=24000; firstline="{1}{1}23.976"
	elif [[ $srt2sub == "ntsc" ]]; then ratio=1; fps=30000; firstline="{1}{1}29.970"
	elif [[ $srt2sub =~ ^[0-9]+$ ]]; then ratio=1; fps=$(($srt2sub * 1001)); firstline="{1}{1}$srt2sub.000"
	elif [[ $srt2sub =~ ^[0-9]+\.[0-9]*$ ]]; then fpsint=${srt2sub%.*}; fpsdecimal=${srt2sub##*.}; decimallength=${#fpsdecimal}; if (( $decimallength == 0 )); then ratio=1; trizero="000"; firstline="{1}{1}$srt2sub$trizero"; else ratio=1$(eval printf '0%.0s' {1..$decimallength}); firstline="{1}{1}$srt2sub"; fi; fps=$(($(echo $fpsint$fpsdecimal) * 1001))
	else echo -e "Error: The srt2sub parameter only accepts the arguments pal, film, ntsc or a custom framerate.\n       Pal = 25, film = 23.976 and ntsc = 29.970"; exit 1
	fi

	if [[ "${inputfilename##*.}" != "srt" ]]; then
		echo "Warning: \"$inputfilename\" does not have '.srt' extension"
	fi


	unix2dos -q "$inputfilename"

	# Read text file to array
	# The encoding must be UTF-8
	old_IFS=$IFS		# save the field separator
	IFS=$'\n'			# new field separator, the end of line

	encoding=$(file -b --mime-encoding $inputfilename)
	for line in $(iconv -f $encoding -t utf-8 "$inputfilename"); do
		arraysrt+=($line)
	done


	# Remove non necessary lines
	regextime="^([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9]) --> ([0-9][0-9]):([0-9][0-9]):([0-9][0-9]),([0-9][0-9][0-9])"

	newarraysrt=()
	for ((i=0; i<=${#arraysrt[@]}; i++)); do
		if [[ ${arraysrt[$(($i + 1))]} =~ $regextime ]] || [[ ${arraysrt[$(($i + 2))]} =~ $regextime ]]; then
			:
		else
			newarraysrt+=(${arraysrt[$i]})
		fi
	done


	# Process the newarraysrt and at the same time create the arraysub
	IFS=$'\r'
	elementsub=()
	stringsub=()
	framesub=""
	arraysub=()
	arraysub+=($firstline)

	# Regular expressions for srt tags. They contain possible sub tags because inside the loop they co-exist
	regex_tag_i="^(\|?({[Yy]:[ibus]})*)((<[bus]>)*(<font[^>]*>)*(<[bus]>)*)<i>(.*)</i>((</[bus]>)*(</font>)*(</[bus]>)*)$"
	regex_tag_b="^(\|?({[Yy]:[ibus]})*)((<[ius]>)*(<font[^>]*>)*(<[ius]>)*)<b>(.*)</b>((</[ius]>)*(</font>)*(</[ius]>)*)$"
	regex_tag_u="^(\|?({[Yy]:[ibus]})*)((<[ibs]>)*(<font[^>]*>)*(<[ibs]>)*)<u>(.*)</u>((</[ibs]>)*(</font>)*(</[ibs]>)*)$"
	regex_tag_s="^(\|?({[Yy]:[ibus]})*)((<[ibu]>)*(<font[^>]*>)*(<[ibu]>)*)<s>(.*)</s>((</[ibu]>)*(</font>)*(</[ibu]>)*)$"

	# Regular expressions for multiple tags that need to become one
	regex_merge_y_tags="^(\|?)({y:([ibus])})?({y:([ibus])})?({y:([ibus])})?({y:([ibus])})?(.*)$"
	regex_merge_Y_tags="^({Y:([ibus])})?({Y:([ibus])})?({Y:([ibus])})?({Y:([ibus])})?(.*)$"

	# Regular expression for removing the remaining srt tags
	regexremove="(.*)<[/]?([ibus]|font[^>]*)>(.*)"

	# This was put inside a function because it needs to run twice
	add_arraysub_element ()
	{
		for j in "${elementsub[@]}"; do
			# Search for "<i>" and "</i>", remove them from the text and add {Y:i} if the subtitle is 1 line or {y:i} if it's more
			if [[ $j =~ $regex_tag_i ]] && ! [[ ${BASH_REMATCH[7]} == *"<i>"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</i>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:i}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
				else
					j="${BASH_REMATCH[1]}{y:i}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
				fi
			fi

			# Search for "<b>" and "</b>", remove them from the text and add {Y:b} if the subtitle is 1 line or {y:b} if it's more
			if [[ $j =~ $regex_tag_b ]] && ! [[ ${BASH_REMATCH[7]} == *"<b>"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</b>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:b}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
				else
					j="${BASH_REMATCH[1]}{y:b}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
				fi
			fi

			# Search for "<u>" and "</u>", remove them from the text and add {Y:u} if the subtitle is 1 line or {y:u} if it's more
			if [[ $j =~ $regex_tag_u ]] && ! [[ ${BASH_REMATCH[7]} == *"<u>"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</u>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:u}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
				else
					j="${BASH_REMATCH[1]}{y:u}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
				fi
			fi

			# Search for "<s>" and "</s>", remove them from the text and add {Y:s} if the subtitle is 1 line or {y:s} if it's more
			if [[ $j =~ $regex_tag_s ]] && ! [[ ${BASH_REMATCH[7]} == *"<s>"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</s>"* ]]; then
				if [[ ${#elementsub[@]} == 1 ]]; then
					j="${BASH_REMATCH[1]}{Y:s}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
				else
					j="${BASH_REMATCH[1]}{y:s}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
				fi
			fi

			# Merge multiple y tags
			if [[ $j =~ $regex_merge_y_tags ]] && [[ ${BASH_REMATCH[2]} ]]; then
				j="${BASH_REMATCH[1]}{y:${BASH_REMATCH[3]}${BASH_REMATCH[5]}${BASH_REMATCH[7]}${BASH_REMATCH[9]}}${BASH_REMATCH[10]}"
			fi

			stringsub=${stringsub:+$stringsub}$j
		done

		# Search for "<s>" and "</s>" that enclose all lines, remove them from the text and add {Y:s}
		if [[ $stringsub =~ $regex_tag_s ]] && ! [[ ${BASH_REMATCH[7]} == *"<s>"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</s>"* ]]; then
			stringsub="{Y:s}${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
		fi

		# Search for "<u>" and "</u>" that enclose all lines, remove them from the text and add {Y:u}
		if [[ $stringsub =~ $regex_tag_u ]] && ! [[ ${BASH_REMATCH[7]} == *"<u>"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</u>"* ]]; then
			stringsub="{Y:u}${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
		fi

		# Search for "<b>" and "</b>" that enclose all lines, remove them from the text and add {Y:b}
		if [[ $stringsub =~ $regex_tag_b ]] && ! [[ ${BASH_REMATCH[7]} == *"<b>"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</b>"* ]]; then
			stringsub="{Y:b}${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
		fi

		# Search for "<i>" and "</i>" that enclose all lines, remove them from the text and add {Y:i}
		if [[ $stringsub =~ $regex_tag_i ]] && ! [[ ${BASH_REMATCH[7]} == *"<i>"* ]] && ! [[ ${BASH_REMATCH[7]} == *"</i>"* ]]; then
			stringsub="{Y:i}${BASH_REMATCH[1]}${BASH_REMATCH[3]}${BASH_REMATCH[7]}${BASH_REMATCH[8]}"
		fi

		# Merge multiple Y tags
		if [[ $stringsub =~ $regex_merge_Y_tags ]] && [[ ${BASH_REMATCH[1]} ]]; then
			stringsub="{Y:${BASH_REMATCH[2]}${BASH_REMATCH[4]}${BASH_REMATCH[6]}${BASH_REMATCH[8]}}${BASH_REMATCH[9]}"
		fi

		arraysub+=($framesub$stringsub)
	}

	for ((i=0; i<${#newarraysrt[@]}; i++)); do
		line=${newarraysrt[$i]}

		if [[ $line =~ $regextime ]]; then
			# Remove empty lines at the end
			while :; do
				if (( ${#elementsub[@]} > 0 )) && (( ${#elementsub[-1]} == 1 )); then
					unset elementsub[-1]
				else
					break
				fi
			done

			h1="${BASH_REMATCH[1]}"
			m1="${BASH_REMATCH[2]}"
			s1="${BASH_REMATCH[3]}"
			f1="${BASH_REMATCH[4]}"

			h2="${BASH_REMATCH[5]}"
			m2="${BASH_REMATCH[6]}"
			s2="${BASH_REMATCH[7]}"
			f2="${BASH_REMATCH[8]}"

			p1=$(($(($((10#$h1)) * 3600000)) + $(($((10#$m1)) * 60000)) + $(($((10#$s1)) * 1000)) + $((10#$f1))))
			p2=$(($(($((10#$h2)) * 3600000)) + $(($((10#$m2)) * 60000)) + $(($((10#$s2)) * 1000)) + $((10#$f2))))

			framesstart=$(($fps * $p1 / (($ratio * 1001000))))
			framesend=$(($fps * $p2 / (($ratio * 1001000))))

			add_arraysub_element

			unset elementsub
			stringsub=""

			framesub="{$framesstart}{$framesend}"

		elif [[ $elementsub ]]; then
			elementsub+=(\|$line)
		else
			elementsub+=($line)
		fi
	done

	# Remove empty lines at the end
	while :; do
		if (( ${#elementsub[@]} > 0 )) && (( ${#elementsub[-1]} == 1 )); then
			unset elementsub[-1]
		else
			break
		fi
	done

	# Run for the last subtitle
	add_arraysub_element

	# Write to the txt file the contents of array.
	if (( ${#arraysub[@]} >= 1 )); then
		newfilename="${inputfilename%.*}.sub"
		echo "Converting \"$inputfilename\" to \"$newfilename\"..."
		printf "%s\n" "${arraysub[@]}" | iconv -f utf-8 -t $encoding > "$newfilename"
	else
		echo "Error: Not a valid srt file"; exit 1
	fi
	IFS=$old_IFS		# restore default field separator
}


if [[ $inputfilename ]]; then
	if [[ $shifttime ]]; then
		shift_time
	elif [[ $pal2ntsc ]]; then
		change_fps
	elif [[ $ntsc2pal ]]; then
		change_fps
	elif [[ $adjustfirst ]]; then
		adjust_time
	elif [[ $synchronizefile ]]; then
		synchronize_with_file
	elif [[ $replace1 ]]; then
		replace_text
	elif [[ $replace3 ]]; then
		replace_text
	elif [[ $sub2srt ]]; then
		sub2_srt
	elif [[ $srt2sub ]]; then
		srt2_sub
	fi
	exit 0
fi
